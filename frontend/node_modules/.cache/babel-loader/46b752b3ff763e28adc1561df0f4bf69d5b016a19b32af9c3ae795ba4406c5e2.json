{"ast":null,"code":"import{getStackSeriesIdentifier}from'../../../util/stacks/getStackSeriesIdentifier';import{getValueByDataKey}from'../../../util/ChartUtils';/**\n * In a stacked chart, each graphical item has its own data. That data could be either:\n * - defined on the chart root, in which case the item gets a unique dataKey\n * - or defined on the item itself, in which case multiple items can share the same dataKey\n *\n * That means we cannot use the dataKey as a unique identifier for the item.\n *\n * This type represents a single data point in a stacked chart, where each key is a series identifier\n * and the value is the numeric value for that series using the numerical axis dataKey.\n */export function combineDisplayedStackedData(stackedGraphicalItems,_ref,tooltipAxisSettings){var{chartData=[]}=_ref;var{allowDuplicatedCategory,dataKey:tooltipDataKey}=tooltipAxisSettings;// A map of tooltip data keys to the stacked data points\nvar knownItemsByDataKey=new Map();stackedGraphicalItems.forEach(item=>{var _item$data;// If there is no data on the individual item then we use the root chart data\nvar resolvedData=(_item$data=item.data)!==null&&_item$data!==void 0?_item$data:chartData;if(resolvedData==null||resolvedData.length===0){// if that doesn't work then we skip this item\nreturn;}var stackIdentifier=getStackSeriesIdentifier(item);resolvedData.forEach((entry,index)=>{var tooltipValue=tooltipDataKey==null||allowDuplicatedCategory?index:String(getValueByDataKey(entry,tooltipDataKey,null));var numericValue=getValueByDataKey(entry,item.dataKey,0);var curr;if(knownItemsByDataKey.has(tooltipValue)){curr=knownItemsByDataKey.get(tooltipValue);}else{curr={};}Object.assign(curr,{[stackIdentifier]:numericValue});knownItemsByDataKey.set(tooltipValue,curr);});});return Array.from(knownItemsByDataKey.values());}","map":{"version":3,"names":["getStackSeriesIdentifier","getValueByDataKey","combineDisplayedStackedData","stackedGraphicalItems","_ref","tooltipAxisSettings","chartData","allowDuplicatedCategory","dataKey","tooltipDataKey","knownItemsByDataKey","Map","forEach","item","_item$data","resolvedData","data","length","stackIdentifier","entry","index","tooltipValue","String","numericValue","curr","has","get","Object","assign","set","Array","from","values"],"sources":["E:/program/ai交友网站demo/dating-app/frontend/src/node_modules/recharts/es6/state/selectors/combiners/combineDisplayedStackedData.js"],"sourcesContent":["import { getStackSeriesIdentifier } from '../../../util/stacks/getStackSeriesIdentifier';\nimport { getValueByDataKey } from '../../../util/ChartUtils';\n\n/**\n * In a stacked chart, each graphical item has its own data. That data could be either:\n * - defined on the chart root, in which case the item gets a unique dataKey\n * - or defined on the item itself, in which case multiple items can share the same dataKey\n *\n * That means we cannot use the dataKey as a unique identifier for the item.\n *\n * This type represents a single data point in a stacked chart, where each key is a series identifier\n * and the value is the numeric value for that series using the numerical axis dataKey.\n */\n\nexport function combineDisplayedStackedData(stackedGraphicalItems, _ref, tooltipAxisSettings) {\n  var {\n    chartData = []\n  } = _ref;\n  var {\n    allowDuplicatedCategory,\n    dataKey: tooltipDataKey\n  } = tooltipAxisSettings;\n\n  // A map of tooltip data keys to the stacked data points\n  var knownItemsByDataKey = new Map();\n  stackedGraphicalItems.forEach(item => {\n    var _item$data;\n    // If there is no data on the individual item then we use the root chart data\n    var resolvedData = (_item$data = item.data) !== null && _item$data !== void 0 ? _item$data : chartData;\n    if (resolvedData == null || resolvedData.length === 0) {\n      // if that doesn't work then we skip this item\n      return;\n    }\n    var stackIdentifier = getStackSeriesIdentifier(item);\n    resolvedData.forEach((entry, index) => {\n      var tooltipValue = tooltipDataKey == null || allowDuplicatedCategory ? index : String(getValueByDataKey(entry, tooltipDataKey, null));\n      var numericValue = getValueByDataKey(entry, item.dataKey, 0);\n      var curr;\n      if (knownItemsByDataKey.has(tooltipValue)) {\n        curr = knownItemsByDataKey.get(tooltipValue);\n      } else {\n        curr = {};\n      }\n      Object.assign(curr, {\n        [stackIdentifier]: numericValue\n      });\n      knownItemsByDataKey.set(tooltipValue, curr);\n    });\n  });\n  return Array.from(knownItemsByDataKey.values());\n}"],"mappings":"AAAA,OAASA,wBAAwB,KAAQ,+CAA+C,CACxF,OAASC,iBAAiB,KAAQ,0BAA0B,CAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAEA,MAAO,SAAS,CAAAC,2BAA2BA,CAACC,qBAAqB,CAAEC,IAAI,CAAEC,mBAAmB,CAAE,CAC5F,GAAI,CACFC,SAAS,CAAG,EACd,CAAC,CAAGF,IAAI,CACR,GAAI,CACFG,uBAAuB,CACvBC,OAAO,CAAEC,cACX,CAAC,CAAGJ,mBAAmB,CAEvB;AACA,GAAI,CAAAK,mBAAmB,CAAG,GAAI,CAAAC,GAAG,CAAC,CAAC,CACnCR,qBAAqB,CAACS,OAAO,CAACC,IAAI,EAAI,CACpC,GAAI,CAAAC,UAAU,CACd;AACA,GAAI,CAAAC,YAAY,CAAG,CAACD,UAAU,CAAGD,IAAI,CAACG,IAAI,IAAM,IAAI,EAAIF,UAAU,GAAK,IAAK,EAAC,CAAGA,UAAU,CAAGR,SAAS,CACtG,GAAIS,YAAY,EAAI,IAAI,EAAIA,YAAY,CAACE,MAAM,GAAK,CAAC,CAAE,CACrD;AACA,OACF,CACA,GAAI,CAAAC,eAAe,CAAGlB,wBAAwB,CAACa,IAAI,CAAC,CACpDE,YAAY,CAACH,OAAO,CAAC,CAACO,KAAK,CAAEC,KAAK,GAAK,CACrC,GAAI,CAAAC,YAAY,CAAGZ,cAAc,EAAI,IAAI,EAAIF,uBAAuB,CAAGa,KAAK,CAAGE,MAAM,CAACrB,iBAAiB,CAACkB,KAAK,CAAEV,cAAc,CAAE,IAAI,CAAC,CAAC,CACrI,GAAI,CAAAc,YAAY,CAAGtB,iBAAiB,CAACkB,KAAK,CAAEN,IAAI,CAACL,OAAO,CAAE,CAAC,CAAC,CAC5D,GAAI,CAAAgB,IAAI,CACR,GAAId,mBAAmB,CAACe,GAAG,CAACJ,YAAY,CAAC,CAAE,CACzCG,IAAI,CAAGd,mBAAmB,CAACgB,GAAG,CAACL,YAAY,CAAC,CAC9C,CAAC,IAAM,CACLG,IAAI,CAAG,CAAC,CAAC,CACX,CACAG,MAAM,CAACC,MAAM,CAACJ,IAAI,CAAE,CAClB,CAACN,eAAe,EAAGK,YACrB,CAAC,CAAC,CACFb,mBAAmB,CAACmB,GAAG,CAACR,YAAY,CAAEG,IAAI,CAAC,CAC7C,CAAC,CAAC,CACJ,CAAC,CAAC,CACF,MAAO,CAAAM,KAAK,CAACC,IAAI,CAACrB,mBAAmB,CAACsB,MAAM,CAAC,CAAC,CAAC,CACjD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}