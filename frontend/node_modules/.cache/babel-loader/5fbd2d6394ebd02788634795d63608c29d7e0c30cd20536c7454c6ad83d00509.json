{"ast":null,"code":"import{shallowEqual}from'react-redux';var propsToShallowCompare=new Set(['axisLine','tickLine','activeBar','activeDot','activeLabel','activeShape','allowEscapeViewBox','background','cursor','dot','label','line','margin','padding','position','shape','style','tick','wrapperStyle']);/**\n * When comparing two values, returns true if they are the same value or\n * are both NaN.\n *\n * If we used just a simple triple equals, we would get false negatives for two NaNs\n * which could cause extra re-renders so let's have this instead.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Equality_comparisons_and_sameness#same-value-zero_equality\n *\n * @param x first value to compare\n * @param y second value to compare\n * return true if the same, false if different\n */function sameValueZero(x,y){if(x==null&&y==null){/*\n     * treat null and undefined as equal. Internally in Recharts we make no difference between these two\n     * so there is no need to re-render.\n     */return true;}if(typeof x==='number'&&typeof y==='number'){// x and y are equal (this is true for -0 and 0) or they are both NaN\n// eslint-disable-next-line no-self-compare\nreturn x===y||x!==x&&y!==y;}return x===y;}/**\n * So usually React would compare only the first level of props using Object.is.\n * However, in our case many props are objects or arrays, and our own docs recommend to do that!\n * Therefore, we need a custom comparison function that does a shallow comparison of each prop value.\n *\n * Because charts can and do receive large props (typically the data array),\n * we only limit this to a subset of known props that are likely to be objects/arrays.\n *\n * @param prevProps\n * @param nextProps\n */export function propsAreEqual(prevProps,nextProps){var allKeys=new Set([...Object.keys(prevProps),...Object.keys(nextProps)]);for(var key of allKeys){/*\n     * If a key is on a special allowlist, go one level deeper\n     * and do a shallow comparison of the values.\n     */if(propsToShallowCompare.has(key)){if(prevProps[key]==null&&nextProps[key]==null){/*\n         * treat null and undefined as equal. Internally in Recharts we make no difference between these two\n         * so there is no need to re-render.\n         */continue;}if(!shallowEqual(prevProps[key],nextProps[key])){return false;}/*\n       * Otherwise do a simple same-value comparison (with NaN support).\n       */}else if(!sameValueZero(prevProps[key],nextProps[key])){return false;}}return true;}","map":{"version":3,"names":["shallowEqual","propsToShallowCompare","Set","sameValueZero","x","y","propsAreEqual","prevProps","nextProps","allKeys","Object","keys","key","has"],"sources":["E:/program/ai交友网站demo/dating-app/frontend/src/node_modules/recharts/es6/util/propsAreEqual.js"],"sourcesContent":["import { shallowEqual } from 'react-redux';\nvar propsToShallowCompare = new Set(['axisLine', 'tickLine', 'activeBar', 'activeDot', 'activeLabel', 'activeShape', 'allowEscapeViewBox', 'background', 'cursor', 'dot', 'label', 'line', 'margin', 'padding', 'position', 'shape', 'style', 'tick', 'wrapperStyle']);\n\n/**\n * When comparing two values, returns true if they are the same value or\n * are both NaN.\n *\n * If we used just a simple triple equals, we would get false negatives for two NaNs\n * which could cause extra re-renders so let's have this instead.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Equality_comparisons_and_sameness#same-value-zero_equality\n *\n * @param x first value to compare\n * @param y second value to compare\n * return true if the same, false if different\n */\nfunction sameValueZero(x, y) {\n  if (x == null && y == null) {\n    /*\n     * treat null and undefined as equal. Internally in Recharts we make no difference between these two\n     * so there is no need to re-render.\n     */\n    return true;\n  }\n  if (typeof x === 'number' && typeof y === 'number') {\n    // x and y are equal (this is true for -0 and 0) or they are both NaN\n    // eslint-disable-next-line no-self-compare\n    return x === y || x !== x && y !== y;\n  }\n  return x === y;\n}\n\n/**\n * So usually React would compare only the first level of props using Object.is.\n * However, in our case many props are objects or arrays, and our own docs recommend to do that!\n * Therefore, we need a custom comparison function that does a shallow comparison of each prop value.\n *\n * Because charts can and do receive large props (typically the data array),\n * we only limit this to a subset of known props that are likely to be objects/arrays.\n *\n * @param prevProps\n * @param nextProps\n */\nexport function propsAreEqual(prevProps, nextProps) {\n  var allKeys = new Set([...Object.keys(prevProps), ...Object.keys(nextProps)]);\n  for (var key of allKeys) {\n    /*\n     * If a key is on a special allowlist, go one level deeper\n     * and do a shallow comparison of the values.\n     */\n    if (propsToShallowCompare.has(key)) {\n      if (prevProps[key] == null && nextProps[key] == null) {\n        /*\n         * treat null and undefined as equal. Internally in Recharts we make no difference between these two\n         * so there is no need to re-render.\n         */\n        continue;\n      }\n      if (!shallowEqual(prevProps[key], nextProps[key])) {\n        return false;\n      }\n      /*\n       * Otherwise do a simple same-value comparison (with NaN support).\n       */\n    } else if (!sameValueZero(prevProps[key], nextProps[key])) {\n      return false;\n    }\n  }\n  return true;\n}"],"mappings":"AAAA,OAASA,YAAY,KAAQ,aAAa,CAC1C,GAAI,CAAAC,qBAAqB,CAAG,GAAI,CAAAC,GAAG,CAAC,CAAC,UAAU,CAAE,UAAU,CAAE,WAAW,CAAE,WAAW,CAAE,aAAa,CAAE,aAAa,CAAE,oBAAoB,CAAE,YAAY,CAAE,QAAQ,CAAE,KAAK,CAAE,OAAO,CAAE,MAAM,CAAE,QAAQ,CAAE,SAAS,CAAE,UAAU,CAAE,OAAO,CAAE,OAAO,CAAE,MAAM,CAAE,cAAc,CAAC,CAAC,CAEtQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAAS,CAAAC,aAAaA,CAACC,CAAC,CAAEC,CAAC,CAAE,CAC3B,GAAID,CAAC,EAAI,IAAI,EAAIC,CAAC,EAAI,IAAI,CAAE,CAC1B;AACJ;AACA;AACA,OACI,MAAO,KAAI,CACb,CACA,GAAI,MAAO,CAAAD,CAAC,GAAK,QAAQ,EAAI,MAAO,CAAAC,CAAC,GAAK,QAAQ,CAAE,CAClD;AACA;AACA,MAAO,CAAAD,CAAC,GAAKC,CAAC,EAAID,CAAC,GAAKA,CAAC,EAAIC,CAAC,GAAKA,CAAC,CACtC,CACA,MAAO,CAAAD,CAAC,GAAKC,CAAC,CAChB,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAAC,aAAaA,CAACC,SAAS,CAAEC,SAAS,CAAE,CAClD,GAAI,CAAAC,OAAO,CAAG,GAAI,CAAAP,GAAG,CAAC,CAAC,GAAGQ,MAAM,CAACC,IAAI,CAACJ,SAAS,CAAC,CAAE,GAAGG,MAAM,CAACC,IAAI,CAACH,SAAS,CAAC,CAAC,CAAC,CAC7E,IAAK,GAAI,CAAAI,GAAG,GAAI,CAAAH,OAAO,CAAE,CACvB;AACJ;AACA;AACA,OACI,GAAIR,qBAAqB,CAACY,GAAG,CAACD,GAAG,CAAC,CAAE,CAClC,GAAIL,SAAS,CAACK,GAAG,CAAC,EAAI,IAAI,EAAIJ,SAAS,CAACI,GAAG,CAAC,EAAI,IAAI,CAAE,CACpD;AACR;AACA;AACA,WACQ,SACF,CACA,GAAI,CAACZ,YAAY,CAACO,SAAS,CAACK,GAAG,CAAC,CAAEJ,SAAS,CAACI,GAAG,CAAC,CAAC,CAAE,CACjD,MAAO,MAAK,CACd,CACA;AACN;AACA,SACI,CAAC,IAAM,IAAI,CAACT,aAAa,CAACI,SAAS,CAACK,GAAG,CAAC,CAAEJ,SAAS,CAACI,GAAG,CAAC,CAAC,CAAE,CACzD,MAAO,MAAK,CACd,CACF,CACA,MAAO,KAAI,CACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}