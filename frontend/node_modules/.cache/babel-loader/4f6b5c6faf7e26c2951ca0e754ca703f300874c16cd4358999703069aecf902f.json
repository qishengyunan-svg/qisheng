{"ast":null,"code":"import _objectSpread from\"E:/program/ai\\u4EA4\\u53CB\\u7F51\\u7AD9demo/dating-app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// src/utils/env.ts\nvar NOTHING=Symbol.for(\"immer-nothing\");var DRAFTABLE=Symbol.for(\"immer-draftable\");var DRAFT_STATE=Symbol.for(\"immer-state\");// src/utils/errors.ts\nvar errors=process.env.NODE_ENV!==\"production\"?[// All error codes, starting by 0:\nfunction(plugin){return\"The plugin for '\".concat(plugin,\"' has not been loaded into Immer. To enable the plugin, import and call `enable\").concat(plugin,\"()` when initializing your application.\");},function(thing){return\"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\".concat(thing,\"'\");},\"This object has been frozen and should not be mutated\",function(data){return\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \"+data;},\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\"Immer forbids circular references\",\"The first or second argument to `produce` must be a function\",\"The third argument to `produce` must be a function or undefined\",\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\"First argument to `finishDraft` must be a draft returned by `createDraft`\",function(thing){return\"'current' expects a draft, got: \".concat(thing);},\"Object.defineProperty() cannot be used on an Immer draft\",\"Object.setPrototypeOf() cannot be used on an Immer draft\",\"Immer only supports deleting array indices\",\"Immer only supports setting array indices and the 'length' property\",function(thing){return\"'original' expects a draft, got: \".concat(thing);}// Note: if more errors are added, the errorOffset in Patches.ts should be increased\n// See Patches.ts for additional errors\n]:[];function die(error){if(process.env.NODE_ENV!==\"production\"){const e=errors[error];for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key2=1;_key2<_len;_key2++){args[_key2-1]=arguments[_key2];}const msg=isFunction(e)?e.apply(null,args):e;throw new Error(\"[Immer] \".concat(msg));}throw new Error(\"[Immer] minified error nr: \".concat(error,\". Full error at: https://bit.ly/3cXEKWf\"));}// src/utils/common.ts\nvar O=Object;var getPrototypeOf=O.getPrototypeOf;var CONSTRUCTOR=\"constructor\";var PROTOTYPE=\"prototype\";var CONFIGURABLE=\"configurable\";var ENUMERABLE=\"enumerable\";var WRITABLE=\"writable\";var VALUE=\"value\";var isDraft=value=>!!value&&!!value[DRAFT_STATE];function isDraftable(value){var _value$CONSTRUCTOR;if(!value)return false;return isPlainObject(value)||isArray(value)||!!value[DRAFTABLE]||!!((_value$CONSTRUCTOR=value[CONSTRUCTOR])!==null&&_value$CONSTRUCTOR!==void 0&&_value$CONSTRUCTOR[DRAFTABLE])||isMap(value)||isSet(value);}var objectCtorString=O[PROTOTYPE][CONSTRUCTOR].toString();var cachedCtorStrings=/* @__PURE__ */new WeakMap();function isPlainObject(value){if(!value||!isObjectish(value))return false;const proto=getPrototypeOf(value);if(proto===null||proto===O[PROTOTYPE])return true;const Ctor=O.hasOwnProperty.call(proto,CONSTRUCTOR)&&proto[CONSTRUCTOR];if(Ctor===Object)return true;if(!isFunction(Ctor))return false;let ctorString=cachedCtorStrings.get(Ctor);if(ctorString===void 0){ctorString=Function.toString.call(Ctor);cachedCtorStrings.set(Ctor,ctorString);}return ctorString===objectCtorString;}function original(value){if(!isDraft(value))die(15,value);return value[DRAFT_STATE].base_;}function each(obj,iter){let strict=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(getArchtype(obj)===0/* Object */){const keys=strict?Reflect.ownKeys(obj):O.keys(obj);keys.forEach(key=>{iter(key,obj[key],obj);});}else{obj.forEach((entry,index)=>iter(index,entry,obj));}}function getArchtype(thing){const state=thing[DRAFT_STATE];return state?state.type_:isArray(thing)?1/* Array */:isMap(thing)?2/* Map */:isSet(thing)?3/* Set */:0/* Object */;}var has=function(thing,prop){let type=arguments.length>2&&arguments[2]!==undefined?arguments[2]:getArchtype(thing);return type===2/* Map */?thing.has(prop):O[PROTOTYPE].hasOwnProperty.call(thing,prop);};var get=function(thing,prop){let type=arguments.length>2&&arguments[2]!==undefined?arguments[2]:getArchtype(thing);return(// @ts-ignore\ntype===2/* Map */?thing.get(prop):thing[prop]);};var set=function(thing,propOrOldValue,value){let type=arguments.length>3&&arguments[3]!==undefined?arguments[3]:getArchtype(thing);if(type===2/* Map */)thing.set(propOrOldValue,value);else if(type===3/* Set */){thing.add(value);}else thing[propOrOldValue]=value;};function is(x,y){if(x===y){return x!==0||1/x===1/y;}else{return x!==x&&y!==y;}}var isArray=Array.isArray;var isMap=target=>target instanceof Map;var isSet=target=>target instanceof Set;var isObjectish=target=>typeof target===\"object\";var isFunction=target=>typeof target===\"function\";var isBoolean=target=>typeof target===\"boolean\";var getProxyDraft=value=>{if(!isObjectish(value))return null;return value===null||value===void 0?void 0:value[DRAFT_STATE];};var latest=state=>state.copy_||state.base_;var getValue=value=>{var _proxyDraft$copy_;const proxyDraft=getProxyDraft(value);return proxyDraft?(_proxyDraft$copy_=proxyDraft.copy_)!==null&&_proxyDraft$copy_!==void 0?_proxyDraft$copy_:proxyDraft.base_:value;};var getFinalValue=state=>state.modified_?state.copy_:state.base_;function shallowCopy(base,strict){if(isMap(base)){return new Map(base);}if(isSet(base)){return new Set(base);}if(isArray(base))return Array[PROTOTYPE].slice.call(base);const isPlain=isPlainObject(base);if(strict===true||strict===\"class_only\"&&!isPlain){const descriptors=O.getOwnPropertyDescriptors(base);delete descriptors[DRAFT_STATE];let keys=Reflect.ownKeys(descriptors);for(let i=0;i<keys.length;i++){const key=keys[i];const desc=descriptors[key];if(desc[WRITABLE]===false){desc[WRITABLE]=true;desc[CONFIGURABLE]=true;}if(desc.get||desc.set)descriptors[key]={[CONFIGURABLE]:true,[WRITABLE]:true,// could live with !!desc.set as well here...\n[ENUMERABLE]:desc[ENUMERABLE],[VALUE]:base[key]};}return O.create(getPrototypeOf(base),descriptors);}else{const proto=getPrototypeOf(base);if(proto!==null&&isPlain){return _objectSpread({},base);}const obj=O.create(proto);return O.assign(obj,base);}}function freeze(obj){let deep=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(isFrozen(obj)||isDraft(obj))return obj;if(getArchtype(obj)>1){O.defineProperties(obj,{set:dontMutateMethodOverride,add:dontMutateMethodOverride,clear:dontMutateMethodOverride,delete:dontMutateMethodOverride});}O.freeze(obj);if(deep)each(obj,(_key,value)=>{freeze(value,true);},false);return obj;}function dontMutateFrozenCollections(){die(2);}var dontMutateMethodOverride={[VALUE]:dontMutateFrozenCollections};function isFrozen(obj){if(obj===null||!isObjectish(obj))return true;return O.isFrozen(obj);}// src/utils/plugins.ts\nvar PluginMapSet=\"MapSet\";var PluginPatches=\"Patches\";var plugins={};function getPlugin(pluginKey){const plugin=plugins[pluginKey];if(!plugin){die(0,pluginKey);}return plugin;}var isPluginLoaded=pluginKey=>!!plugins[pluginKey];function loadPlugin(pluginKey,implementation){if(!plugins[pluginKey])plugins[pluginKey]=implementation;}// src/core/scope.ts\nvar currentScope;var getCurrentScope=()=>currentScope;var createScope=(parent_,immer_)=>({drafts_:[],parent_,immer_,// Whenever the modified draft contains a draft from another scope, we\n// need to prevent auto-freezing so the unowned draft can be finalized.\ncanAutoFreeze_:true,unfinalizedDrafts_:0,handledSet_:/* @__PURE__ */new Set(),processedForPatches_:/* @__PURE__ */new Set(),mapSetPlugin_:isPluginLoaded(PluginMapSet)?getPlugin(PluginMapSet):void 0});function usePatchesInScope(scope,patchListener){if(patchListener){scope.patchPlugin_=getPlugin(PluginPatches);scope.patches_=[];scope.inversePatches_=[];scope.patchListener_=patchListener;}}function revokeScope(scope){leaveScope(scope);scope.drafts_.forEach(revokeDraft);scope.drafts_=null;}function leaveScope(scope){if(scope===currentScope){currentScope=scope.parent_;}}var enterScope=immer2=>currentScope=createScope(currentScope,immer2);function revokeDraft(draft){const state=draft[DRAFT_STATE];if(state.type_===0/* Object */||state.type_===1/* Array */)state.revoke_();else state.revoked_=true;}// src/core/finalize.ts\nfunction processResult(result,scope){scope.unfinalizedDrafts_=scope.drafts_.length;const baseDraft=scope.drafts_[0];const isReplaced=result!==void 0&&result!==baseDraft;if(isReplaced){if(baseDraft[DRAFT_STATE].modified_){revokeScope(scope);die(4);}if(isDraftable(result)){result=finalize(scope,result);}const{patchPlugin_}=scope;if(patchPlugin_){patchPlugin_.generateReplacementPatches_(baseDraft[DRAFT_STATE].base_,result,scope);}}else{result=finalize(scope,baseDraft);}maybeFreeze(scope,result,true);revokeScope(scope);if(scope.patches_){scope.patchListener_(scope.patches_,scope.inversePatches_);}return result!==NOTHING?result:void 0;}function finalize(rootScope,value){if(isFrozen(value))return value;const state=value[DRAFT_STATE];if(!state){const finalValue=handleValue(value,rootScope.handledSet_,rootScope);return finalValue;}if(!isSameScope(state,rootScope)){return value;}if(!state.modified_){return state.base_;}if(!state.finalized_){const{callbacks_}=state;if(callbacks_){while(callbacks_.length>0){const callback=callbacks_.pop();callback(rootScope);}}generatePatchesAndFinalize(state,rootScope);}return state.copy_;}function maybeFreeze(scope,value){let deep=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(!scope.parent_&&scope.immer_.autoFreeze_&&scope.canAutoFreeze_){freeze(value,deep);}}function markStateFinalized(state){state.finalized_=true;state.scope_.unfinalizedDrafts_--;}var isSameScope=(state,rootScope)=>state.scope_===rootScope;var EMPTY_LOCATIONS_RESULT=[];function updateDraftInParent(parent,draftValue,finalizedValue,originalKey){var _parent$draftLocation;const parentCopy=latest(parent);const parentType=parent.type_;if(originalKey!==void 0){const currentValue=get(parentCopy,originalKey,parentType);if(currentValue===draftValue){set(parentCopy,originalKey,finalizedValue,parentType);return;}}if(!parent.draftLocations_){const draftLocations=parent.draftLocations_=/* @__PURE__ */new Map();each(parentCopy,(key,value)=>{if(isDraft(value)){const keys=draftLocations.get(value)||[];keys.push(key);draftLocations.set(value,keys);}});}const locations=(_parent$draftLocation=parent.draftLocations_.get(draftValue))!==null&&_parent$draftLocation!==void 0?_parent$draftLocation:EMPTY_LOCATIONS_RESULT;for(const location of locations){set(parentCopy,location,finalizedValue,parentType);}}function registerChildFinalizationCallback(parent,child,key){parent.callbacks_.push(function childCleanup(rootScope){var _rootScope$mapSetPlug,_state$draft_;const state=child;if(!state||!isSameScope(state,rootScope)){return;}(_rootScope$mapSetPlug=rootScope.mapSetPlugin_)===null||_rootScope$mapSetPlug===void 0?void 0:_rootScope$mapSetPlug.fixSetContents(state);const finalizedValue=getFinalValue(state);updateDraftInParent(parent,(_state$draft_=state.draft_)!==null&&_state$draft_!==void 0?_state$draft_:state,finalizedValue,key);generatePatchesAndFinalize(state,rootScope);});}function generatePatchesAndFinalize(state,rootScope){var _state$assigned_$size,_state$assigned_;const shouldFinalize=state.modified_&&!state.finalized_&&(state.type_===3/* Set */||((_state$assigned_$size=(_state$assigned_=state.assigned_)===null||_state$assigned_===void 0?void 0:_state$assigned_.size)!==null&&_state$assigned_$size!==void 0?_state$assigned_$size:0)>0);if(shouldFinalize){const{patchPlugin_}=rootScope;if(patchPlugin_){const basePath=patchPlugin_.getPath(state);if(basePath){patchPlugin_.generatePatches_(state,basePath,rootScope);}}markStateFinalized(state);}}function handleCrossReference(target,key,value){const{scope_}=target;if(isDraft(value)){const state=value[DRAFT_STATE];if(isSameScope(state,scope_)){state.callbacks_.push(function crossReferenceCleanup(){prepareCopy(target);const finalizedValue=getFinalValue(state);updateDraftInParent(target,value,finalizedValue,key);});}}else if(isDraftable(value)){target.callbacks_.push(function nestedDraftCleanup(){const targetCopy=latest(target);if(get(targetCopy,key,target.type_)===value){var _target$assigned_$get;if(scope_.drafts_.length>1&&((_target$assigned_$get=target.assigned_.get(key))!==null&&_target$assigned_$get!==void 0?_target$assigned_$get:false)===true&&target.copy_){handleValue(get(target.copy_,key,target.type_),scope_.handledSet_,scope_);}}});}}function handleValue(target,handledSet,rootScope){if(!rootScope.immer_.autoFreeze_&&rootScope.unfinalizedDrafts_<1){return target;}if(isDraft(target)||handledSet.has(target)||!isDraftable(target)||isFrozen(target)){return target;}handledSet.add(target);each(target,(key,value)=>{if(isDraft(value)){const state=value[DRAFT_STATE];if(isSameScope(state,rootScope)){const updatedValue=getFinalValue(state);set(target,key,updatedValue,target.type_);markStateFinalized(state);}}else if(isDraftable(value)){handleValue(value,handledSet,rootScope);}});return target;}// src/core/proxy.ts\nfunction createProxyProxy(base,parent){const baseIsArray=isArray(base);const state={type_:baseIsArray?1/* Array */:0/* Object */,// Track which produce call this is associated with.\nscope_:parent?parent.scope_:getCurrentScope(),// True for both shallow and deep changes.\nmodified_:false,// Used during finalization.\nfinalized_:false,// Track which properties have been assigned (true) or deleted (false).\n// actually instantiated in `prepareCopy()`\nassigned_:void 0,// The parent draft state.\nparent_:parent,// The base state.\nbase_:base,// The base proxy.\ndraft_:null,// set below\n// The base copy with any updated values.\ncopy_:null,// Called by the `produce` function.\nrevoke_:null,isManual_:false,// `callbacks` actually gets assigned in `createProxy`\ncallbacks_:void 0};let target=state;let traps=objectTraps;if(baseIsArray){target=[state];traps=arrayTraps;}const{revoke,proxy}=Proxy.revocable(target,traps);state.draft_=proxy;state.revoke_=revoke;return[proxy,state];}var objectTraps={get(state,prop){if(prop===DRAFT_STATE)return state;const source=latest(state);if(!has(source,prop,state.type_)){return readPropFromProto(state,source,prop);}const value=source[prop];if(state.finalized_||!isDraftable(value)){return value;}if(value===peek(state.base_,prop)){prepareCopy(state);const childKey=state.type_===1/* Array */?+prop:prop;const childDraft=createProxy(state.scope_,value,state,childKey);return state.copy_[childKey]=childDraft;}return value;},has(state,prop){return prop in latest(state);},ownKeys(state){return Reflect.ownKeys(latest(state));},set(state,prop,value){const desc=getDescriptorFromProto(latest(state),prop);if(desc!==null&&desc!==void 0&&desc.set){desc.set.call(state.draft_,value);return true;}if(!state.modified_){const current2=peek(latest(state),prop);const currentState=current2===null||current2===void 0?void 0:current2[DRAFT_STATE];if(currentState&&currentState.base_===value){state.copy_[prop]=value;state.assigned_.set(prop,false);return true;}if(is(value,current2)&&(value!==void 0||has(state.base_,prop,state.type_)))return true;prepareCopy(state);markChanged(state);}if(state.copy_[prop]===value&&(// special case: handle new props with value 'undefined'\nvalue!==void 0||prop in state.copy_)||// special case: NaN\nNumber.isNaN(value)&&Number.isNaN(state.copy_[prop]))return true;state.copy_[prop]=value;state.assigned_.set(prop,true);handleCrossReference(state,prop,value);return true;},deleteProperty(state,prop){prepareCopy(state);if(peek(state.base_,prop)!==void 0||prop in state.base_){state.assigned_.set(prop,false);markChanged(state);}else{state.assigned_.delete(prop);}if(state.copy_){delete state.copy_[prop];}return true;},// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n// the same guarantee in ES5 mode.\ngetOwnPropertyDescriptor(state,prop){const owner=latest(state);const desc=Reflect.getOwnPropertyDescriptor(owner,prop);if(!desc)return desc;return{[WRITABLE]:true,[CONFIGURABLE]:state.type_!==1/* Array */||prop!==\"length\",[ENUMERABLE]:desc[ENUMERABLE],[VALUE]:owner[prop]};},defineProperty(){die(11);},getPrototypeOf(state){return getPrototypeOf(state.base_);},setPrototypeOf(){die(12);}};var arrayTraps={};each(objectTraps,(key,fn)=>{arrayTraps[key]=function(){const args=arguments;args[0]=args[0][0];return fn.apply(this,args);};});arrayTraps.deleteProperty=function(state,prop){if(process.env.NODE_ENV!==\"production\"&&isNaN(parseInt(prop)))die(13);return arrayTraps.set.call(this,state,prop,void 0);};arrayTraps.set=function(state,prop,value){if(process.env.NODE_ENV!==\"production\"&&prop!==\"length\"&&isNaN(parseInt(prop)))die(14);return objectTraps.set.call(this,state[0],prop,value,state[0]);};function peek(draft,prop){const state=draft[DRAFT_STATE];const source=state?latest(state):draft;return source[prop];}function readPropFromProto(state,source,prop){var _desc$get;const desc=getDescriptorFromProto(source,prop);return desc?VALUE in desc?desc[VALUE]:// This is a very special case, if the prop is a getter defined by the\n// prototype, we should invoke it with the draft as context!\n(_desc$get=desc.get)===null||_desc$get===void 0?void 0:_desc$get.call(state.draft_):void 0;}function getDescriptorFromProto(source,prop){if(!(prop in source))return void 0;let proto=getPrototypeOf(source);while(proto){const desc=Object.getOwnPropertyDescriptor(proto,prop);if(desc)return desc;proto=getPrototypeOf(proto);}return void 0;}function markChanged(state){if(!state.modified_){state.modified_=true;if(state.parent_){markChanged(state.parent_);}}}function prepareCopy(state){if(!state.copy_){state.assigned_=/* @__PURE__ */new Map();state.copy_=shallowCopy(state.base_,state.scope_.immer_.useStrictShallowCopy_);}}// src/core/immerClass.ts\nvar Immer2=class{constructor(config){var _this=this;this.autoFreeze_=true;this.useStrictShallowCopy_=false;this.useStrictIteration_=false;/**\n     * The `produce` function takes a value and a \"recipe function\" (whose\n     * return value often depends on the base state). The recipe function is\n     * free to mutate its first argument however it wants. All mutations are\n     * only ever applied to a __copy__ of the base state.\n     *\n     * Pass only a function to create a \"curried producer\" which relieves you\n     * from passing the recipe function every time.\n     *\n     * Only plain objects and arrays are made mutable. All other objects are\n     * considered uncopyable.\n     *\n     * Note: This function is __bound__ to its `Immer` instance.\n     *\n     * @param {any} base - the initial state\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\n     * @returns {any} a new state, or the initial state if nothing was modified\n     */this.produce=(base,recipe,patchListener)=>{if(isFunction(base)&&!isFunction(recipe)){const defaultBase=recipe;recipe=base;const self=this;return function curriedProduce(){let base2=arguments.length>0&&arguments[0]!==undefined?arguments[0]:defaultBase;for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key3=1;_key3<_len2;_key3++){args[_key3-1]=arguments[_key3];}return self.produce(base2,draft=>recipe.call(this,draft,...args));};}if(!isFunction(recipe))die(6);if(patchListener!==void 0&&!isFunction(patchListener))die(7);let result;if(isDraftable(base)){const scope=enterScope(this);const proxy=createProxy(scope,base,void 0);let hasError=true;try{result=recipe(proxy);hasError=false;}finally{if(hasError)revokeScope(scope);else leaveScope(scope);}usePatchesInScope(scope,patchListener);return processResult(result,scope);}else if(!base||!isObjectish(base)){result=recipe(base);if(result===void 0)result=base;if(result===NOTHING)result=void 0;if(this.autoFreeze_)freeze(result,true);if(patchListener){const p=[];const ip=[];getPlugin(PluginPatches).generateReplacementPatches_(base,result,{patches_:p,inversePatches_:ip});patchListener(p,ip);}return result;}else die(1,base);};this.produceWithPatches=(base,recipe)=>{if(isFunction(base)){return function(state){for(var _len3=arguments.length,args=new Array(_len3>1?_len3-1:0),_key4=1;_key4<_len3;_key4++){args[_key4-1]=arguments[_key4];}return _this.produceWithPatches(state,draft=>base(draft,...args));};}let patches,inversePatches;const result=this.produce(base,recipe,(p,ip)=>{patches=p;inversePatches=ip;});return[result,patches,inversePatches];};if(isBoolean(config===null||config===void 0?void 0:config.autoFreeze))this.setAutoFreeze(config.autoFreeze);if(isBoolean(config===null||config===void 0?void 0:config.useStrictShallowCopy))this.setUseStrictShallowCopy(config.useStrictShallowCopy);if(isBoolean(config===null||config===void 0?void 0:config.useStrictIteration))this.setUseStrictIteration(config.useStrictIteration);}createDraft(base){if(!isDraftable(base))die(8);if(isDraft(base))base=current(base);const scope=enterScope(this);const proxy=createProxy(scope,base,void 0);proxy[DRAFT_STATE].isManual_=true;leaveScope(scope);return proxy;}finishDraft(draft,patchListener){const state=draft&&draft[DRAFT_STATE];if(!state||!state.isManual_)die(9);const{scope_:scope}=state;usePatchesInScope(scope,patchListener);return processResult(void 0,scope);}/**\n   * Pass true to automatically freeze all copies created by Immer.\n   *\n   * By default, auto-freezing is enabled.\n   */setAutoFreeze(value){this.autoFreeze_=value;}/**\n   * Pass true to enable strict shallow copy.\n   *\n   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n   */setUseStrictShallowCopy(value){this.useStrictShallowCopy_=value;}/**\n   * Pass false to use faster iteration that skips non-enumerable properties\n   * but still handles symbols for compatibility.\n   *\n   * By default, strict iteration is enabled (includes all own properties).\n   */setUseStrictIteration(value){this.useStrictIteration_=value;}shouldUseStrictIteration(){return this.useStrictIteration_;}applyPatches(base,patches){let i;for(i=patches.length-1;i>=0;i--){const patch=patches[i];if(patch.path.length===0&&patch.op===\"replace\"){base=patch.value;break;}}if(i>-1){patches=patches.slice(i+1);}const applyPatchesImpl=getPlugin(PluginPatches).applyPatches_;if(isDraft(base)){return applyPatchesImpl(base,patches);}return this.produce(base,draft=>applyPatchesImpl(draft,patches));}};function createProxy(rootScope,value,parent,key){var _parent$scope_,_parent$callbacks_;const[draft,state]=isMap(value)?getPlugin(PluginMapSet).proxyMap_(value,parent):isSet(value)?getPlugin(PluginMapSet).proxySet_(value,parent):createProxyProxy(value,parent);const scope=(_parent$scope_=parent===null||parent===void 0?void 0:parent.scope_)!==null&&_parent$scope_!==void 0?_parent$scope_:getCurrentScope();scope.drafts_.push(draft);state.callbacks_=(_parent$callbacks_=parent===null||parent===void 0?void 0:parent.callbacks_)!==null&&_parent$callbacks_!==void 0?_parent$callbacks_:[];state.key_=key;if(parent&&key!==void 0){registerChildFinalizationCallback(parent,state,key);}else{state.callbacks_.push(function rootDraftCleanup(rootScope2){var _rootScope2$mapSetPlu;(_rootScope2$mapSetPlu=rootScope2.mapSetPlugin_)===null||_rootScope2$mapSetPlu===void 0?void 0:_rootScope2$mapSetPlu.fixSetContents(state);const{patchPlugin_}=rootScope2;if(state.modified_&&patchPlugin_){patchPlugin_.generatePatches_(state,[],rootScope2);}});}return draft;}// src/core/current.ts\nfunction current(value){if(!isDraft(value))die(10,value);return currentImpl(value);}function currentImpl(value){if(!isDraftable(value)||isFrozen(value))return value;const state=value[DRAFT_STATE];let copy;let strict=true;if(state){if(!state.modified_)return state.base_;state.finalized_=true;copy=shallowCopy(value,state.scope_.immer_.useStrictShallowCopy_);strict=state.scope_.immer_.shouldUseStrictIteration();}else{copy=shallowCopy(value,true);}each(copy,(key,childValue)=>{set(copy,key,currentImpl(childValue));},strict);if(state){state.finalized_=false;}return copy;}// src/plugins/patches.ts\nfunction enablePatches(){const errorOffset=16;if(process.env.NODE_ENV!==\"production\"){errors.push('Sets cannot have \"replace\" patches.',function(op){return\"Unsupported patch operation: \"+op;},function(path){return\"Cannot apply patch, path doesn't resolve: \"+path;},\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\");}function getPath(state){let path=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];if(\"key_\"in state&&state.key_!==void 0){var _state$parent_$copy_;const parentCopy=(_state$parent_$copy_=state.parent_.copy_)!==null&&_state$parent_$copy_!==void 0?_state$parent_$copy_:state.parent_.base_;const proxyDraft=getProxyDraft(get(parentCopy,state.key_));const valueAtKey=get(parentCopy,state.key_);if(valueAtKey===void 0){return null;}if(valueAtKey!==state.draft_&&valueAtKey!==state.base_&&valueAtKey!==state.copy_){return null;}if(proxyDraft!=null&&proxyDraft.base_!==state.base_){return null;}const isSet2=state.parent_.type_===3/* Set */;let key;if(isSet2){const setParent=state.parent_;key=Array.from(setParent.drafts_.keys()).indexOf(state.key_);}else{key=state.key_;}if(!(isSet2&&parentCopy.size>key||has(parentCopy,key))){return null;}path.push(key);}if(state.parent_){return getPath(state.parent_,path);}path.reverse();try{resolvePath(state.copy_,path);}catch(e){return null;}return path;}function resolvePath(base,path){let current2=base;for(let i=0;i<path.length-1;i++){const key=path[i];current2=get(current2,key);if(!isObjectish(current2)||current2===null){throw new Error(\"Cannot resolve path at '\".concat(path.join(\"/\"),\"'\"));}}return current2;}const REPLACE=\"replace\";const ADD=\"add\";const REMOVE=\"remove\";function generatePatches_(state,basePath,scope){if(state.scope_.processedForPatches_.has(state)){return;}state.scope_.processedForPatches_.add(state);const{patches_,inversePatches_}=scope;switch(state.type_){case 0/* Object */:case 2/* Map */:return generatePatchesFromAssigned(state,basePath,patches_,inversePatches_);case 1/* Array */:return generateArrayPatches(state,basePath,patches_,inversePatches_);case 3/* Set */:return generateSetPatches(state,basePath,patches_,inversePatches_);}}function generateArrayPatches(state,basePath,patches,inversePatches){let{base_,assigned_}=state;let copy_=state.copy_;if(copy_.length<base_.length){;[base_,copy_]=[copy_,base_];[patches,inversePatches]=[inversePatches,patches];}for(let i=0;i<base_.length;i++){const copiedItem=copy_[i];const baseItem=base_[i];if(assigned_!==null&&assigned_!==void 0&&assigned_.get(i.toString())&&copiedItem!==baseItem){const childState=copiedItem===null||copiedItem===void 0?void 0:copiedItem[DRAFT_STATE];if(childState&&childState.modified_){continue;}const path=basePath.concat([i]);patches.push({op:REPLACE,path,// Need to maybe clone it, as it can in fact be the original value\n// due to the base/copy inversion at the start of this function\nvalue:clonePatchValueIfNeeded(copiedItem)});inversePatches.push({op:REPLACE,path,value:clonePatchValueIfNeeded(baseItem)});}}for(let i=base_.length;i<copy_.length;i++){const path=basePath.concat([i]);patches.push({op:ADD,path,// Need to maybe clone it, as it can in fact be the original value\n// due to the base/copy inversion at the start of this function\nvalue:clonePatchValueIfNeeded(copy_[i])});}for(let i=copy_.length-1;base_.length<=i;--i){const path=basePath.concat([i]);inversePatches.push({op:REMOVE,path});}}function generatePatchesFromAssigned(state,basePath,patches,inversePatches){const{base_,copy_,type_}=state;each(state.assigned_,(key,assignedValue)=>{const origValue=get(base_,key,type_);const value=get(copy_,key,type_);const op=!assignedValue?REMOVE:has(base_,key)?REPLACE:ADD;if(origValue===value&&op===REPLACE)return;const path=basePath.concat(key);patches.push(op===REMOVE?{op,path}:{op,path,value:clonePatchValueIfNeeded(value)});inversePatches.push(op===ADD?{op:REMOVE,path}:op===REMOVE?{op:ADD,path,value:clonePatchValueIfNeeded(origValue)}:{op:REPLACE,path,value:clonePatchValueIfNeeded(origValue)});});}function generateSetPatches(state,basePath,patches,inversePatches){let{base_,copy_}=state;let i=0;base_.forEach(value=>{if(!copy_.has(value)){const path=basePath.concat([i]);patches.push({op:REMOVE,path,value});inversePatches.unshift({op:ADD,path,value});}i++;});i=0;copy_.forEach(value=>{if(!base_.has(value)){const path=basePath.concat([i]);patches.push({op:ADD,path,value});inversePatches.unshift({op:REMOVE,path,value});}i++;});}function generateReplacementPatches_(baseValue,replacement,scope){const{patches_,inversePatches_}=scope;patches_.push({op:REPLACE,path:[],value:replacement===NOTHING?void 0:replacement});inversePatches_.push({op:REPLACE,path:[],value:baseValue});}function applyPatches_(draft,patches){patches.forEach(patch=>{const{path,op}=patch;let base=draft;for(let i=0;i<path.length-1;i++){const parentType=getArchtype(base);let p=path[i];if(typeof p!==\"string\"&&typeof p!==\"number\"){p=\"\"+p;}if((parentType===0/* Object */||parentType===1/* Array */)&&(p===\"__proto__\"||p===CONSTRUCTOR))die(errorOffset+3);if(isFunction(base)&&p===PROTOTYPE)die(errorOffset+3);base=get(base,p);if(!isObjectish(base))die(errorOffset+2,path.join(\"/\"));}const type=getArchtype(base);const value=deepClonePatchValue(patch.value);const key=path[path.length-1];switch(op){case REPLACE:switch(type){case 2/* Map */:return base.set(key,value);case 3/* Set */:die(errorOffset);default:return base[key]=value;}case ADD:switch(type){case 1/* Array */:return key===\"-\"?base.push(value):base.splice(key,0,value);case 2/* Map */:return base.set(key,value);case 3/* Set */:return base.add(value);default:return base[key]=value;}case REMOVE:switch(type){case 1/* Array */:return base.splice(key,1);case 2/* Map */:return base.delete(key);case 3/* Set */:return base.delete(patch.value);default:return delete base[key];}default:die(errorOffset+1,op);}});return draft;}function deepClonePatchValue(obj){if(!isDraftable(obj))return obj;if(isArray(obj))return obj.map(deepClonePatchValue);if(isMap(obj))return new Map(Array.from(obj.entries()).map(_ref=>{let[k,v]=_ref;return[k,deepClonePatchValue(v)];}));if(isSet(obj))return new Set(Array.from(obj).map(deepClonePatchValue));const cloned=Object.create(getPrototypeOf(obj));for(const key in obj)cloned[key]=deepClonePatchValue(obj[key]);if(has(obj,DRAFTABLE))cloned[DRAFTABLE]=obj[DRAFTABLE];return cloned;}function clonePatchValueIfNeeded(obj){if(isDraft(obj)){return deepClonePatchValue(obj);}else return obj;}loadPlugin(PluginPatches,{applyPatches_,generatePatches_,generateReplacementPatches_,getPath});}// src/plugins/mapset.ts\nfunction enableMapSet(){class DraftMap extends Map{constructor(target,parent){super();this[DRAFT_STATE]={type_:2/* Map */,parent_:parent,scope_:parent?parent.scope_:getCurrentScope(),modified_:false,finalized_:false,copy_:void 0,assigned_:void 0,base_:target,draft_:this,isManual_:false,revoked_:false,callbacks_:[]};}get size(){return latest(this[DRAFT_STATE]).size;}has(key){return latest(this[DRAFT_STATE]).has(key);}set(key,value){const state=this[DRAFT_STATE];assertUnrevoked(state);if(!latest(state).has(key)||latest(state).get(key)!==value){prepareMapCopy(state);markChanged(state);state.assigned_.set(key,true);state.copy_.set(key,value);state.assigned_.set(key,true);}return this;}delete(key){if(!this.has(key)){return false;}const state=this[DRAFT_STATE];assertUnrevoked(state);prepareMapCopy(state);markChanged(state);if(state.base_.has(key)){state.assigned_.set(key,false);}else{state.assigned_.delete(key);}state.copy_.delete(key);return true;}clear(){const state=this[DRAFT_STATE];assertUnrevoked(state);if(latest(state).size){prepareMapCopy(state);markChanged(state);state.assigned_=/* @__PURE__ */new Map();each(state.base_,key=>{state.assigned_.set(key,false);});state.copy_.clear();}}forEach(cb,thisArg){const state=this[DRAFT_STATE];latest(state).forEach((_value,key,_map)=>{cb.call(thisArg,this.get(key),key,this);});}get(key){const state=this[DRAFT_STATE];assertUnrevoked(state);const value=latest(state).get(key);if(state.finalized_||!isDraftable(value)){return value;}if(value!==state.base_.get(key)){return value;}const draft=createProxy(state.scope_,value,state,key);prepareMapCopy(state);state.copy_.set(key,draft);return draft;}keys(){return latest(this[DRAFT_STATE]).keys();}values(){const iterator=this.keys();return{[Symbol.iterator]:()=>this.values(),next:()=>{const r=iterator.next();if(r.done)return r;const value=this.get(r.value);return{done:false,value};}};}entries(){const iterator=this.keys();return{[Symbol.iterator]:()=>this.entries(),next:()=>{const r=iterator.next();if(r.done)return r;const value=this.get(r.value);return{done:false,value:[r.value,value]};}};}[(DRAFT_STATE,Symbol.iterator)](){return this.entries();}}function proxyMap_(target,parent){const map=new DraftMap(target,parent);return[map,map[DRAFT_STATE]];}function prepareMapCopy(state){if(!state.copy_){state.assigned_=/* @__PURE__ */new Map();state.copy_=new Map(state.base_);}}class DraftSet extends Set{constructor(target,parent){super();this[DRAFT_STATE]={type_:3/* Set */,parent_:parent,scope_:parent?parent.scope_:getCurrentScope(),modified_:false,finalized_:false,copy_:void 0,base_:target,draft_:this,drafts_:/* @__PURE__ */new Map(),revoked_:false,isManual_:false,assigned_:void 0,callbacks_:[]};}get size(){return latest(this[DRAFT_STATE]).size;}has(value){const state=this[DRAFT_STATE];assertUnrevoked(state);if(!state.copy_){return state.base_.has(value);}if(state.copy_.has(value))return true;if(state.drafts_.has(value)&&state.copy_.has(state.drafts_.get(value)))return true;return false;}add(value){const state=this[DRAFT_STATE];assertUnrevoked(state);if(!this.has(value)){prepareSetCopy(state);markChanged(state);state.copy_.add(value);}return this;}delete(value){if(!this.has(value)){return false;}const state=this[DRAFT_STATE];assertUnrevoked(state);prepareSetCopy(state);markChanged(state);return state.copy_.delete(value)||(state.drafts_.has(value)?state.copy_.delete(state.drafts_.get(value)):(/* istanbul ignore next */false));}clear(){const state=this[DRAFT_STATE];assertUnrevoked(state);if(latest(state).size){prepareSetCopy(state);markChanged(state);state.copy_.clear();}}values(){const state=this[DRAFT_STATE];assertUnrevoked(state);prepareSetCopy(state);return state.copy_.values();}entries(){const state=this[DRAFT_STATE];assertUnrevoked(state);prepareSetCopy(state);return state.copy_.entries();}keys(){return this.values();}[(DRAFT_STATE,Symbol.iterator)](){return this.values();}forEach(cb,thisArg){const iterator=this.values();let result=iterator.next();while(!result.done){cb.call(thisArg,result.value,result.value,this);result=iterator.next();}}}function proxySet_(target,parent){const set2=new DraftSet(target,parent);return[set2,set2[DRAFT_STATE]];}function prepareSetCopy(state){if(!state.copy_){state.copy_=/* @__PURE__ */new Set();state.base_.forEach(value=>{if(isDraftable(value)){const draft=createProxy(state.scope_,value,state,value);state.drafts_.set(value,draft);state.copy_.add(draft);}else{state.copy_.add(value);}});}}function assertUnrevoked(state){if(state.revoked_)die(3,JSON.stringify(latest(state)));}function fixSetContents(target){if(target.type_===3/* Set */&&target.copy_){const copy=new Set(target.copy_);target.copy_.clear();copy.forEach(value=>{target.copy_.add(getValue(value));});}}loadPlugin(PluginMapSet,{proxyMap_,proxySet_,fixSetContents});}// src/immer.ts\nvar immer=new Immer2();var produce=immer.produce;var produceWithPatches=/* @__PURE__ */immer.produceWithPatches.bind(immer);var setAutoFreeze=/* @__PURE__ */immer.setAutoFreeze.bind(immer);var setUseStrictShallowCopy=/* @__PURE__ */immer.setUseStrictShallowCopy.bind(immer);var setUseStrictIteration=/* @__PURE__ */immer.setUseStrictIteration.bind(immer);var applyPatches=/* @__PURE__ */immer.applyPatches.bind(immer);var createDraft=/* @__PURE__ */immer.createDraft.bind(immer);var finishDraft=/* @__PURE__ */immer.finishDraft.bind(immer);var castDraft=value=>value;var castImmutable=value=>value;export{Immer2 as Immer,applyPatches,castDraft,castImmutable,createDraft,current,enableMapSet,enablePatches,finishDraft,freeze,DRAFTABLE as immerable,isDraft,isDraftable,NOTHING as nothing,original,produce,produceWithPatches,setAutoFreeze,setUseStrictIteration,setUseStrictShallowCopy};","map":{"version":3,"names":["NOTHING","Symbol","for","DRAFTABLE","DRAFT_STATE","errors","process","env","NODE_ENV","plugin","concat","thing","data","die","error","e","_len","arguments","length","args","Array","_key2","msg","isFunction","apply","Error","O","Object","getPrototypeOf","CONSTRUCTOR","PROTOTYPE","CONFIGURABLE","ENUMERABLE","WRITABLE","VALUE","isDraft","value","isDraftable","_value$CONSTRUCTOR","isPlainObject","isArray","isMap","isSet","objectCtorString","toString","cachedCtorStrings","WeakMap","isObjectish","proto","Ctor","hasOwnProperty","call","ctorString","get","Function","set","original","base_","each","obj","iter","strict","undefined","getArchtype","keys","Reflect","ownKeys","forEach","key","entry","index","state","type_","has","prop","type","propOrOldValue","add","is","x","y","target","Map","Set","isBoolean","getProxyDraft","latest","copy_","getValue","_proxyDraft$copy_","proxyDraft","getFinalValue","modified_","shallowCopy","base","slice","isPlain","descriptors","getOwnPropertyDescriptors","i","desc","create","_objectSpread","assign","freeze","deep","isFrozen","defineProperties","dontMutateMethodOverride","clear","delete","_key","dontMutateFrozenCollections","PluginMapSet","PluginPatches","plugins","getPlugin","pluginKey","isPluginLoaded","loadPlugin","implementation","currentScope","getCurrentScope","createScope","parent_","immer_","drafts_","canAutoFreeze_","unfinalizedDrafts_","handledSet_","processedForPatches_","mapSetPlugin_","usePatchesInScope","scope","patchListener","patchPlugin_","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer2","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","finalize","generateReplacementPatches_","maybeFreeze","rootScope","finalValue","handleValue","isSameScope","finalized_","callbacks_","callback","pop","generatePatchesAndFinalize","autoFreeze_","markStateFinalized","scope_","EMPTY_LOCATIONS_RESULT","updateDraftInParent","parent","draftValue","finalizedValue","originalKey","_parent$draftLocation","parentCopy","parentType","currentValue","draftLocations_","draftLocations","push","locations","location","registerChildFinalizationCallback","child","childCleanup","_rootScope$mapSetPlug","_state$draft_","fixSetContents","draft_","_state$assigned_$size","_state$assigned_","shouldFinalize","assigned_","size","basePath","getPath","generatePatches_","handleCrossReference","crossReferenceCleanup","prepareCopy","nestedDraftCleanup","targetCopy","_target$assigned_$get","handledSet","updatedValue","createProxyProxy","baseIsArray","isManual_","traps","objectTraps","arrayTraps","revoke","proxy","Proxy","revocable","source","readPropFromProto","peek","childKey","childDraft","createProxy","getDescriptorFromProto","current2","currentState","markChanged","Number","isNaN","deleteProperty","getOwnPropertyDescriptor","owner","defineProperty","setPrototypeOf","fn","parseInt","_desc$get","useStrictShallowCopy_","Immer2","constructor","config","_this","useStrictIteration_","produce","recipe","defaultBase","self","curriedProduce","base2","_len2","_key3","hasError","p","ip","produceWithPatches","_len3","_key4","patches","inversePatches","autoFreeze","setAutoFreeze","useStrictShallowCopy","setUseStrictShallowCopy","useStrictIteration","setUseStrictIteration","createDraft","current","finishDraft","shouldUseStrictIteration","applyPatches","patch","path","op","applyPatchesImpl","applyPatches_","_parent$scope_","_parent$callbacks_","proxyMap_","proxySet_","key_","rootDraftCleanup","rootScope2","_rootScope2$mapSetPlu","currentImpl","copy","childValue","enablePatches","errorOffset","_state$parent_$copy_","valueAtKey","isSet2","setParent","from","indexOf","reverse","resolvePath","join","REPLACE","ADD","REMOVE","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","copiedItem","baseItem","childState","clonePatchValueIfNeeded","assignedValue","origValue","unshift","baseValue","replacement","deepClonePatchValue","splice","map","entries","_ref","k","v","cloned","enableMapSet","DraftMap","assertUnrevoked","prepareMapCopy","cb","thisArg","_value","_map","values","iterator","next","r","done","DraftSet","prepareSetCopy","set2","JSON","stringify","immer","bind","castDraft","castImmutable"],"sources":["E:\\program\\ai交友网站demo\\dating-app\\frontend\\src\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\utils\\env.ts","E:\\program\\ai交友网站demo\\dating-app\\frontend\\src\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\utils\\errors.ts","E:\\program\\ai交友网站demo\\dating-app\\frontend\\src\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\utils\\common.ts","E:\\program\\ai交友网站demo\\dating-app\\frontend\\src\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\utils\\plugins.ts","E:\\program\\ai交友网站demo\\dating-app\\frontend\\src\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\core\\scope.ts","E:\\program\\ai交友网站demo\\dating-app\\frontend\\src\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\core\\finalize.ts","E:\\program\\ai交友网站demo\\dating-app\\frontend\\src\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\core\\proxy.ts","E:\\program\\ai交友网站demo\\dating-app\\frontend\\src\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\core\\immerClass.ts","E:\\program\\ai交友网站demo\\dating-app\\frontend\\src\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\core\\current.ts","E:\\program\\ai交友网站demo\\dating-app\\frontend\\src\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\plugins\\patches.ts","E:\\program\\ai交友网站demo\\dating-app\\frontend\\src\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\plugins\\mapset.ts","E:\\program\\ai交友网站demo\\dating-app\\frontend\\src\\node_modules\\@reduxjs\\toolkit\\node_modules\\immer\\src\\immer.ts"],"sourcesContent":["// Should be no imports here!\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: unique symbol = Symbol.for(\"immer-nothing\")\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = Symbol.for(\"immer-draftable\")\n\nexport const DRAFT_STATE: unique symbol = Symbol.for(\"immer-state\")\n","import {isFunction} from \"../internal\"\n\nexport const errors =\n\tprocess.env.NODE_ENV !== \"production\"\n\t\t? [\n\t\t\t\t// All error codes, starting by 0:\n\t\t\t\tfunction(plugin: string) {\n\t\t\t\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t\t\t\t},\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t\t\t\t},\n\t\t\t\t\"This object has been frozen and should not be mutated\",\n\t\t\t\tfunction(data: any) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\t\t\tdata\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t\t\t\t\"Immer forbids circular references\",\n\t\t\t\t\"The first or second argument to `produce` must be a function\",\n\t\t\t\t\"The third argument to `produce` must be a function or undefined\",\n\t\t\t\t\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t\t\t\t\"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'current' expects a draft, got: ${thing}`\n\t\t\t\t},\n\t\t\t\t\"Object.defineProperty() cannot be used on an Immer draft\",\n\t\t\t\t\"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t\t\t\t\"Immer only supports deleting array indices\",\n\t\t\t\t\"Immer only supports setting array indices and the 'length' property\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'original' expects a draft, got: ${thing}`\n\t\t\t\t}\n\t\t\t\t// Note: if more errors are added, the errorOffset in Patches.ts should be increased\n\t\t\t\t// See Patches.ts for additional errors\n\t\t  ]\n\t\t: []\n\nexport function die(error: number, ...args: any[]): never {\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tconst e = errors[error]\n\t\tconst msg = isFunction(e) ? e.apply(null, args as any) : e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tArchType,\n\tdie,\n\tStrictMode\n} from \"../internal\"\n\nconst O = Object\n\nexport const getPrototypeOf = O.getPrototypeOf\n\nexport const CONSTRUCTOR = \"constructor\"\nexport const PROTOTYPE = \"prototype\"\n\nexport const CONFIGURABLE = \"configurable\"\nexport const ENUMERABLE = \"enumerable\"\nexport const WRITABLE = \"writable\"\nexport const VALUE = \"value\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport let isDraft = (value: any): boolean => !!value && !!value[DRAFT_STATE]\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tisArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value[CONSTRUCTOR]?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = O[PROTOTYPE][CONSTRUCTOR].toString()\nconst cachedCtorStrings = new WeakMap()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || !isObjectish(value)) return false\n\tconst proto = getPrototypeOf(value)\n\tif (proto === null || proto === O[PROTOTYPE]) return true\n\n\tconst Ctor = O.hasOwnProperty.call(proto, CONSTRUCTOR) && proto[CONSTRUCTOR]\n\tif (Ctor === Object) return true\n\n\tif (!isFunction(Ctor)) return false\n\n\tlet ctorString = cachedCtorStrings.get(Ctor)\n\tif (ctorString === undefined) {\n\t\tctorString = Function.toString.call(Ctor)\n\t\tcachedCtorStrings.set(Ctor, ctorString)\n\t}\n\n\treturn ctorString === objectCtorString\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(15, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/**\n * Each iterates a map, set or array.\n * Or, if any other kind of object, all of its own properties.\n *\n * @param obj The object to iterate over\n * @param iter The iterator function\n * @param strict When true (default), includes symbols and non-enumerable properties.\n *               When false, uses looseiteration over only enumerable string properties.\n */\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tstrict?: boolean\n): void\nexport function each(obj: any, iter: any, strict: boolean = true) {\n\tif (getArchtype(obj) === ArchType.Object) {\n\t\t// If strict, we do a full iteration including symbols and non-enumerable properties\n\t\t// Otherwise, we only iterate enumerable string properties for performance\n\t\tconst keys = strict ? Reflect.ownKeys(obj) : O.keys(obj)\n\t\tkeys.forEach(key => {\n\t\t\titer(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): ArchType {\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_\n\t\t: isArray(thing)\n\t\t? ArchType.Array\n\t\t: isMap(thing)\n\t\t? ArchType.Map\n\t\t: isSet(thing)\n\t\t? ArchType.Set\n\t\t: ArchType.Object\n}\n\n/*#__PURE__*/\nexport let has = (\n\tthing: any,\n\tprop: PropertyKey,\n\ttype = getArchtype(thing)\n): boolean =>\n\ttype === ArchType.Map\n\t\t? thing.has(prop)\n\t\t: O[PROTOTYPE].hasOwnProperty.call(thing, prop)\n\n/*#__PURE__*/\nexport let get = (\n\tthing: AnyMap | AnyObject,\n\tprop: PropertyKey,\n\ttype = getArchtype(thing)\n): any =>\n\t// @ts-ignore\n\ttype === ArchType.Map ? thing.get(prop) : thing[prop]\n\n/*#__PURE__*/\nexport let set = (\n\tthing: any,\n\tpropOrOldValue: PropertyKey,\n\tvalue: any,\n\ttype = getArchtype(thing)\n) => {\n\tif (type === ArchType.Map) thing.set(propOrOldValue, value)\n\telse if (type === ArchType.Set) {\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\nexport let isArray = Array.isArray\n\n/*#__PURE__*/\nexport let isMap = (target: any): target is AnyMap => target instanceof Map\n\n/*#__PURE__*/\nexport let isSet = (target: any): target is AnySet => target instanceof Set\n\nexport let isObjectish = (target: any) => typeof target === \"object\"\n\nexport let isFunction = (target: any): target is Function =>\n\ttypeof target === \"function\"\n\nexport let isBoolean = (target: any): target is boolean =>\n\ttypeof target === \"boolean\"\n\nexport let getProxyDraft = <T extends any>(value: T): ImmerState | null => {\n\tif (!isObjectish(value)) return null\n\treturn (value as {[DRAFT_STATE]: any})?.[DRAFT_STATE]\n}\n\n/*#__PURE__*/\nexport let latest = (state: ImmerState): any => state.copy_ || state.base_\n\nexport let getValue = <T extends object>(value: T): T => {\n\tconst proxyDraft = getProxyDraft(value)\n\treturn proxyDraft ? proxyDraft.copy_ ?? proxyDraft.base_ : value\n}\n\nexport let getFinalValue = (state: ImmerState): any =>\n\tstate.modified_ ? state.copy_ : state.base_\n\n/*#__PURE__*/\nexport function shallowCopy(base: any, strict: StrictMode) {\n\tif (isMap(base)) {\n\t\treturn new Map(base)\n\t}\n\tif (isSet(base)) {\n\t\treturn new Set(base)\n\t}\n\tif (isArray(base)) return Array[PROTOTYPE].slice.call(base)\n\n\tconst isPlain = isPlainObject(base)\n\n\tif (strict === true || (strict === \"class_only\" && !isPlain)) {\n\t\t// Perform a strict copy\n\t\tconst descriptors = O.getOwnPropertyDescriptors(base)\n\t\tdelete descriptors[DRAFT_STATE as any]\n\t\tlet keys = Reflect.ownKeys(descriptors)\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key: any = keys[i]\n\t\t\tconst desc = descriptors[key]\n\t\t\tif (desc[WRITABLE] === false) {\n\t\t\t\tdesc[WRITABLE] = true\n\t\t\t\tdesc[CONFIGURABLE] = true\n\t\t\t}\n\t\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t\t// with libraries that trap values, like mobx or vue\n\t\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\t\tif (desc.get || desc.set)\n\t\t\t\tdescriptors[key] = {\n\t\t\t\t\t[CONFIGURABLE]: true,\n\t\t\t\t\t[WRITABLE]: true, // could live with !!desc.set as well here...\n\t\t\t\t\t[ENUMERABLE]: desc[ENUMERABLE],\n\t\t\t\t\t[VALUE]: base[key]\n\t\t\t\t}\n\t\t}\n\t\treturn O.create(getPrototypeOf(base), descriptors)\n\t} else {\n\t\t// perform a sloppy copy\n\t\tconst proto = getPrototypeOf(base)\n\t\tif (proto !== null && isPlain) {\n\t\t\treturn {...base} // assumption: better inner class optimization than the assign below\n\t\t}\n\t\tconst obj = O.create(proto)\n\t\treturn O.assign(obj, base)\n\t}\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tO.defineProperties(obj, {\n\t\t\tset: dontMutateMethodOverride,\n\t\t\tadd: dontMutateMethodOverride,\n\t\t\tclear: dontMutateMethodOverride,\n\t\t\tdelete: dontMutateMethodOverride\n\t\t})\n\t}\n\tO.freeze(obj)\n\tif (deep)\n\t\t// See #590, don't recurse into non-enumerable / Symbol properties when freezing\n\t\t// So use Object.values (only string-like, enumerables) instead of each()\n\t\teach(\n\t\t\tobj,\n\t\t\t(_key, value) => {\n\t\t\t\tfreeze(value, true)\n\t\t\t},\n\t\t\tfalse\n\t\t)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nconst dontMutateMethodOverride = {\n\t[VALUE]: dontMutateFrozenCollections\n}\n\nexport function isFrozen(obj: any): boolean {\n\t// Fast path: primitives and null/undefined are always \"frozen\"\n\tif (obj === null || !isObjectish(obj)) return true\n\treturn O.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tDrafted,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tArchType,\n\tdie,\n\tImmerScope\n} from \"../internal\"\n\nexport const PluginMapSet = \"MapSet\"\nexport const PluginPatches = \"Patches\"\n\nexport type PatchesPlugin = {\n\tgeneratePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\trootScope: ImmerScope\n\t): void\n\tgenerateReplacementPatches_(\n\t\tbase: any,\n\t\treplacement: any,\n\t\trootScope: ImmerScope\n\t): void\n\tapplyPatches_<T>(draft: T, patches: readonly Patch[]): T\n\tgetPath: (state: ImmerState) => PatchPath | null\n}\n\nexport type MapSetPlugin = {\n\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): [T, ImmerState]\n\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): [T, ImmerState]\n\tfixSetContents: (state: ImmerState) => void\n}\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: PatchesPlugin\n\tMapSet?: MapSetPlugin\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(0, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport let isPluginLoaded = <K extends keyof Plugins>(pluginKey: K): boolean =>\n\t!!plugins[pluginKey]\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ArchType.Map\n\tcopy_: AnyMap | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ArchType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tArchType,\n\tgetPlugin,\n\tPatchesPlugin,\n\tMapSetPlugin,\n\tisPluginLoaded,\n\tPluginMapSet,\n\tPluginPatches\n} from \"../internal\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tpatchPlugin_?: PatchesPlugin\n\tmapSetPlugin_?: MapSetPlugin\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n\thandledSet_: Set<any>\n\tprocessedForPatches_: Set<any>\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport let getCurrentScope = () => currentScope!\n\nlet createScope = (\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope => ({\n\tdrafts_: [],\n\tparent_,\n\timmer_,\n\t// Whenever the modified draft contains a draft from another scope, we\n\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\tcanAutoFreeze_: true,\n\tunfinalizedDrafts_: 0,\n\thandledSet_: new Set(),\n\tprocessedForPatches_: new Set(),\n\tmapSetPlugin_: isPluginLoaded(PluginMapSet)\n\t\t? getPlugin(PluginMapSet)\n\t\t: undefined\n})\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tscope.patchPlugin_ = getPlugin(PluginPatches) // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport let enterScope = (immer: Immer) =>\n\t(currentScope = createScope(currentScope, immer))\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (state.type_ === ArchType.Object || state.type_ === ArchType.Array)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tArchType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tget,\n\tPatch,\n\tlatest,\n\tprepareCopy,\n\tgetFinalValue,\n\tgetValue\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t}\n\t\tconst {patchPlugin_} = scope\n\t\tif (patchPlugin_) {\n\t\t\tpatchPlugin_.generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft)\n\t}\n\n\tmaybeFreeze(scope, result, true)\n\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\tif (!state) {\n\t\tconst finalValue = handleValue(value, rootScope.handledSet_, rootScope)\n\t\treturn finalValue\n\t}\n\n\t// Never finalize drafts owned by another scope\n\tif (!isSameScope(state, rootScope)) {\n\t\treturn value\n\t}\n\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\treturn state.base_\n\t}\n\n\tif (!state.finalized_) {\n\t\t// Execute all registered draft finalization callbacks\n\t\tconst {callbacks_} = state\n\t\tif (callbacks_) {\n\t\t\twhile (callbacks_.length > 0) {\n\t\t\t\tconst callback = callbacks_.pop()!\n\t\t\t\tcallback(rootScope)\n\t\t\t}\n\t\t}\n\n\t\tgeneratePatchesAndFinalize(state, rootScope)\n\t}\n\n\t// By now the root copy has been fully updated throughout its tree\n\treturn state.copy_\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\t// we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n\tif (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n\nfunction markStateFinalized(state: ImmerState) {\n\tstate.finalized_ = true\n\tstate.scope_.unfinalizedDrafts_--\n}\n\nlet isSameScope = (state: ImmerState, rootScope: ImmerScope) =>\n\tstate.scope_ === rootScope\n\n// A reusable empty array to avoid allocations\nconst EMPTY_LOCATIONS_RESULT: (string | symbol | number)[] = []\n\n// Updates all references to a draft in its parent to the finalized value.\n// This handles cases where the same draft appears multiple times in the parent, or has been moved around.\nexport function updateDraftInParent(\n\tparent: ImmerState,\n\tdraftValue: any,\n\tfinalizedValue: any,\n\toriginalKey?: string | number | symbol\n): void {\n\tconst parentCopy = latest(parent)\n\tconst parentType = parent.type_\n\n\t// Fast path: Check if draft is still at original key\n\tif (originalKey !== undefined) {\n\t\tconst currentValue = get(parentCopy, originalKey, parentType)\n\t\tif (currentValue === draftValue) {\n\t\t\t// Still at original location, just update it\n\t\t\tset(parentCopy, originalKey, finalizedValue, parentType)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Slow path: Build reverse mapping of all children\n\t// to their indices in the parent, so that we can\n\t// replace all locations where this draft appears.\n\t// We only have to build this once per parent.\n\tif (!parent.draftLocations_) {\n\t\tconst draftLocations = (parent.draftLocations_ = new Map())\n\n\t\t// Use `each` which works on Arrays, Maps, and Objects\n\t\teach(parentCopy, (key, value) => {\n\t\t\tif (isDraft(value)) {\n\t\t\t\tconst keys = draftLocations.get(value) || []\n\t\t\t\tkeys.push(key)\n\t\t\t\tdraftLocations.set(value, keys)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Look up all locations where this draft appears\n\tconst locations =\n\t\tparent.draftLocations_.get(draftValue) ?? EMPTY_LOCATIONS_RESULT\n\n\t// Update all locations\n\tfor (const location of locations) {\n\t\tset(parentCopy, location, finalizedValue, parentType)\n\t}\n}\n\n// Register a callback to finalize a child draft when the parent draft is finalized.\n// This assumes there is a parent -> child relationship between the two drafts,\n// and we have a key to locate the child in the parent.\nexport function registerChildFinalizationCallback(\n\tparent: ImmerState,\n\tchild: ImmerState,\n\tkey: string | number | symbol\n) {\n\tparent.callbacks_.push(function childCleanup(rootScope) {\n\t\tconst state: ImmerState = child\n\n\t\t// Can only continue if this is a draft owned by this scope\n\t\tif (!state || !isSameScope(state, rootScope)) {\n\t\t\treturn\n\t\t}\n\n\t\t// Handle potential set value finalization first\n\t\trootScope.mapSetPlugin_?.fixSetContents(state)\n\n\t\tconst finalizedValue = getFinalValue(state)\n\n\t\t// Update all locations in the parent that referenced this draft\n\t\tupdateDraftInParent(parent, state.draft_ ?? state, finalizedValue, key)\n\n\t\tgeneratePatchesAndFinalize(state, rootScope)\n\t})\n}\n\nfunction generatePatchesAndFinalize(state: ImmerState, rootScope: ImmerScope) {\n\tconst shouldFinalize =\n\t\tstate.modified_ &&\n\t\t!state.finalized_ &&\n\t\t(state.type_ === ArchType.Set || (state.assigned_?.size ?? 0) > 0)\n\n\tif (shouldFinalize) {\n\t\tconst {patchPlugin_} = rootScope\n\t\tif (patchPlugin_) {\n\t\t\tconst basePath = patchPlugin_!.getPath(state)\n\n\t\t\tif (basePath) {\n\t\t\t\tpatchPlugin_!.generatePatches_(state, basePath, rootScope)\n\t\t\t}\n\t\t}\n\n\t\tmarkStateFinalized(state)\n\t}\n}\n\nexport function handleCrossReference(\n\ttarget: ImmerState,\n\tkey: string | number | symbol,\n\tvalue: any\n) {\n\tconst {scope_} = target\n\t// Check if value is a draft from this scope\n\tif (isDraft(value)) {\n\t\tconst state: ImmerState = value[DRAFT_STATE]\n\t\tif (isSameScope(state, scope_)) {\n\t\t\t// Register callback to update this location when the draft finalizes\n\n\t\t\tstate.callbacks_.push(function crossReferenceCleanup() {\n\t\t\t\t// Update the target location with finalized value\n\t\t\t\tprepareCopy(target)\n\n\t\t\t\tconst finalizedValue = getFinalValue(state)\n\n\t\t\t\tupdateDraftInParent(target, value, finalizedValue, key)\n\t\t\t})\n\t\t}\n\t} else if (isDraftable(value)) {\n\t\t// Handle non-draft objects that might contain drafts\n\t\ttarget.callbacks_.push(function nestedDraftCleanup() {\n\t\t\tconst targetCopy = latest(target)\n\n\t\t\tif (get(targetCopy, key, target.type_) === value) {\n\t\t\t\t// Process the value to replace any nested drafts\n\t\t\t\t// finalizeAssigned(target, key, target.scope_)\n\n\t\t\t\tif (\n\t\t\t\t\tscope_.drafts_.length > 1 &&\n\t\t\t\t\t((target as Exclude<ImmerState, SetState>).assigned_!.get(key) ??\n\t\t\t\t\t\tfalse) === true &&\n\t\t\t\t\ttarget.copy_\n\t\t\t\t) {\n\t\t\t\t\t// This might be a non-draft value that has drafts\n\t\t\t\t\t// inside. We do need to recurse here to handle those.\n\t\t\t\t\thandleValue(\n\t\t\t\t\t\tget(target.copy_, key, target.type_),\n\t\t\t\t\t\tscope_.handledSet_,\n\t\t\t\t\t\tscope_\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nexport function handleValue(\n\ttarget: any,\n\thandledSet: Set<any>,\n\trootScope: ImmerScope\n) {\n\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t// This benefits especially adding large data tree's without further processing.\n\t\t// See add-data.js perf test\n\t\treturn target\n\t}\n\n\t// Skip if already handled, frozen, or not draftable\n\tif (\n\t\tisDraft(target) ||\n\t\thandledSet.has(target) ||\n\t\t!isDraftable(target) ||\n\t\tisFrozen(target)\n\t) {\n\t\treturn target\n\t}\n\n\thandledSet.add(target)\n\n\t// Process ALL properties/entries\n\teach(target, (key, value) => {\n\t\tif (isDraft(value)) {\n\t\t\tconst state: ImmerState = value[DRAFT_STATE]\n\t\t\tif (isSameScope(state, rootScope)) {\n\t\t\t\t// Replace draft with finalized value\n\n\t\t\t\tconst updatedValue = getFinalValue(state)\n\n\t\t\t\tset(target, key, updatedValue, target.type_)\n\n\t\t\t\tmarkStateFinalized(state)\n\t\t\t}\n\t\t} else if (isDraftable(value)) {\n\t\t\t// Recursively handle nested values\n\t\t\thandleValue(value, handledSet, rootScope)\n\t\t}\n\t})\n\n\treturn target\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tgetPrototypeOf,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tArchType,\n\tImmerScope,\n\thandleCrossReference,\n\tWRITABLE,\n\tCONFIGURABLE,\n\tENUMERABLE,\n\tVALUE,\n\tisArray\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ArchType.Object\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ArchType.Array\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): [Drafted<T, ProxyState>, ProxyState] {\n\tconst baseIsArray = isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: baseIsArray ? ArchType.Array : (ArchType.Object as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\t// actually instantiated in `prepareCopy()`\n\t\tassigned_: undefined,\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false,\n\t\t// `callbacks` actually gets assigned in `createProxy`\n\t\tcallbacks_: undefined as any\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (baseIsArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn [proxy as any, state]\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop, state.type_)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\t// Ensure array keys are always numbers\n\t\t\tconst childKey = state.type_ === ArchType.Array ? +(prop as string) : prop\n\t\t\tconst childDraft = createProxy(state.scope_, value, state, childKey)\n\n\t\t\treturn (state.copy_![childKey] = childDraft)\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_!.set(prop, false)\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (\n\t\t\t\tis(value, current) &&\n\t\t\t\t(value !== undefined || has(state.base_, prop, state.type_))\n\t\t\t)\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\t(state.copy_![prop] === value &&\n\t\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t\t(value !== undefined || prop in state.copy_)) ||\n\t\t\t// special case: NaN\n\t\t\t(Number.isNaN(value) && Number.isNaN(state.copy_![prop]))\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_!.set(prop, true)\n\n\t\thandleCrossReference(state, prop, value)\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\tprepareCopy(state)\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_!.set(prop, false)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tstate.assigned_!.delete(prop)\n\t\t}\n\t\tif (state.copy_) {\n\t\t\tdelete state.copy_[prop]\n\t\t}\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\t[WRITABLE]: true,\n\t\t\t[CONFIGURABLE]: state.type_ !== ArchType.Array || prop !== \"length\",\n\t\t\t[ENUMERABLE]: desc[ENUMERABLE],\n\t\t\t[VALUE]: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\tconst args = arguments\n\t\targs[0] = args[0][0]\n\t\treturn fn.apply(this, args)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop as any)))\n\t\tdie(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (\n\t\tprocess.env.NODE_ENV !== \"production\" &&\n\t\tprop !== \"length\" &&\n\t\tisNaN(parseInt(prop as any))\n\t)\n\t\tdie(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? VALUE in desc\n\t\t\t? desc[VALUE]\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: ImmerState) {\n\tif (!state.copy_) {\n\t\t// Actually create the `assigned_` map now that we\n\t\t// know this is a modified draft.\n\t\tstate.assigned_ = new Map()\n\t\tstate.copy_ = shallowCopy(\n\t\t\tstate.base_,\n\t\t\tstate.scope_.immer_.useStrictShallowCopy_\n\t\t)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent,\n\tImmerScope,\n\tregisterChildFinalizationCallback,\n\tArchType,\n\tMapSetPlugin,\n\tAnyMap,\n\tAnySet,\n\tisObjectish,\n\tisFunction,\n\tisBoolean,\n\tPluginMapSet,\n\tPluginPatches\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport type StrictMode = boolean | \"class_only\"\n\nexport class Immer implements ProducersFns {\n\tautoFreeze_: boolean = true\n\tuseStrictShallowCopy_: StrictMode = false\n\tuseStrictIteration_: boolean = false\n\n\tconstructor(config?: {\n\t\tautoFreeze?: boolean\n\t\tuseStrictShallowCopy?: StrictMode\n\t\tuseStrictIteration?: boolean\n\t}) {\n\t\tif (isBoolean(config?.autoFreeze)) this.setAutoFreeze(config!.autoFreeze)\n\t\tif (isBoolean(config?.useStrictShallowCopy))\n\t\t\tthis.setUseStrictShallowCopy(config!.useStrictShallowCopy)\n\t\tif (isBoolean(config?.useStrictIteration))\n\t\t\tthis.setUseStrictIteration(config!.useStrictIteration)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (isFunction(base) && !isFunction(recipe)) {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (!isFunction(recipe)) die(6)\n\t\tif (patchListener !== undefined && !isFunction(patchListener)) die(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(scope, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || !isObjectish(base)) {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(PluginPatches).generateReplacementPatches_(base, result, {\n\t\t\t\t\tpatches_: p,\n\t\t\t\t\tinversePatches_: ip\n\t\t\t\t} as ImmerScope) // dummy scope\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(1, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\n\t\t// curried invocation\n\t\tif (isFunction(base)) {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(scope, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (!state || !state.isManual_) die(9)\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to enable strict shallow copy.\n\t *\n\t * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n\t */\n\tsetUseStrictShallowCopy(value: StrictMode) {\n\t\tthis.useStrictShallowCopy_ = value\n\t}\n\n\t/**\n\t * Pass false to use faster iteration that skips non-enumerable properties\n\t * but still handles symbols for compatibility.\n\t *\n\t * By default, strict iteration is enabled (includes all own properties).\n\t */\n\tsetUseStrictIteration(value: boolean) {\n\t\tthis.useStrictIteration_ = value\n\t}\n\n\tshouldUseStrictIteration(): boolean {\n\t\treturn this.useStrictIteration_\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: readonly Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(PluginPatches).applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\trootScope: ImmerScope,\n\tvalue: T,\n\tparent?: ImmerState,\n\tkey?: string | number | symbol\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\t// returning a tuple here lets us skip a proxy access\n\t// to DRAFT_STATE later\n\tconst [draft, state] = isMap(value)\n\t\t? getPlugin(PluginMapSet).proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(PluginMapSet).proxySet_(value, parent)\n\t\t: createProxyProxy(value, parent)\n\n\tconst scope = parent?.scope_ ?? getCurrentScope()\n\tscope.drafts_.push(draft)\n\n\t// Ensure the parent callbacks are passed down so we actually\n\t// track all callbacks added throughout the tree\n\tstate.callbacks_ = parent?.callbacks_ ?? []\n\tstate.key_ = key\n\n\tif (parent && key !== undefined) {\n\t\tregisterChildFinalizationCallback(parent, state, key)\n\t} else {\n\t\t// It's a root draft, register it with the scope\n\t\tstate.callbacks_.push(function rootDraftCleanup(rootScope) {\n\t\t\trootScope.mapSetPlugin_?.fixSetContents(state)\n\n\t\t\tconst {patchPlugin_} = rootScope\n\n\t\t\tif (state.modified_ && patchPlugin_) {\n\t\t\t\tpatchPlugin_.generatePatches_(state, [], rootScope)\n\t\t\t}\n\t\t})\n\t}\n\n\treturn draft as any\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tisFrozen\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(10, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value) || isFrozen(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tlet strict = true // Default to strict for compatibility\n\tif (state) {\n\t\tif (!state.modified_) return state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)\n\t\tstrict = state.scope_.immer_.shouldUseStrictIteration()\n\t} else {\n\t\tcopy = shallowCopy(value, true)\n\t}\n\t// recurse\n\teach(\n\t\tcopy,\n\t\t(key, childValue) => {\n\t\t\tset(copy, key, currentImpl(childValue))\n\t\t},\n\t\tstrict\n\t)\n\tif (state) {\n\t\tstate.finalized_ = false\n\t}\n\treturn copy\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tProxyArrayState,\n\tMapState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tgetPrototypeOf,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tArchType,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING,\n\terrors,\n\tDRAFT_STATE,\n\tgetProxyDraft,\n\tImmerScope,\n\tisObjectish,\n\tisFunction,\n\tCONSTRUCTOR,\n\tPluginPatches,\n\tisArray,\n\tPROTOTYPE\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst errorOffset = 16\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\terrors.push(\n\t\t\t'Sets cannot have \"replace\" patches.',\n\t\t\tfunction(op: string) {\n\t\t\t\treturn \"Unsupported patch operation: \" + op\n\t\t\t},\n\t\t\tfunction(path: string) {\n\t\t\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t\t\t},\n\t\t\t\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t\t)\n\t}\n\n\tfunction getPath(state: ImmerState, path: PatchPath = []): PatchPath | null {\n\t\t// Step 1: Check if state has a stored key\n\t\tif (\"key_\" in state && state.key_ !== undefined) {\n\t\t\t// Step 2: Validate the key is still valid in parent\n\n\t\t\tconst parentCopy = state.parent_!.copy_ ?? state.parent_!.base_\n\t\t\tconst proxyDraft = getProxyDraft(get(parentCopy, state.key_!))\n\t\t\tconst valueAtKey = get(parentCopy, state.key_!)\n\n\t\t\tif (valueAtKey === undefined) {\n\t\t\t\treturn null\n\t\t\t}\n\n\t\t\t// Check if the value at the key is still related to this draft\n\t\t\t// It should be either the draft itself, the base, or the copy\n\t\t\tif (\n\t\t\t\tvalueAtKey !== state.draft_ &&\n\t\t\t\tvalueAtKey !== state.base_ &&\n\t\t\t\tvalueAtKey !== state.copy_\n\t\t\t) {\n\t\t\t\treturn null // Value was replaced with something else\n\t\t\t}\n\t\t\tif (proxyDraft != null && proxyDraft.base_ !== state.base_) {\n\t\t\t\treturn null // Different draft\n\t\t\t}\n\n\t\t\t// Step 3: Handle Set case specially\n\t\t\tconst isSet = state.parent_!.type_ === ArchType.Set\n\t\t\tlet key: string | number\n\n\t\t\tif (isSet) {\n\t\t\t\t// For Sets, find the index in the drafts_ map\n\t\t\t\tconst setParent = state.parent_ as SetState\n\t\t\t\tkey = Array.from(setParent.drafts_.keys()).indexOf(state.key_)\n\t\t\t} else {\n\t\t\t\tkey = state.key_ as string | number\n\t\t\t}\n\n\t\t\t// Step 4: Validate key still exists in parent\n\t\t\tif (!((isSet && parentCopy.size > key) || has(parentCopy, key))) {\n\t\t\t\treturn null // Key deleted\n\t\t\t}\n\n\t\t\t// Step 5: Add key to path\n\t\t\tpath.push(key)\n\t\t}\n\n\t\t// Step 6: Recurse to parent if exists\n\t\tif (state.parent_) {\n\t\t\treturn getPath(state.parent_, path)\n\t\t}\n\n\t\t// Step 7: At root - reverse path and validate\n\t\tpath.reverse()\n\n\t\ttry {\n\t\t\t// Validate path can be resolved from ROOT\n\t\t\tresolvePath(state.copy_, path)\n\t\t} catch (e) {\n\t\t\treturn null // Path invalid\n\t\t}\n\n\t\treturn path\n\t}\n\n\t// NEW: Add resolvePath helper function\n\tfunction resolvePath(base: any, path: PatchPath): any {\n\t\tlet current = base\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst key = path[i]\n\t\t\tcurrent = get(current, key)\n\t\t\tif (!isObjectish(current) || current === null) {\n\t\t\t\tthrow new Error(`Cannot resolve path at '${path.join(\"/\")}'`)\n\t\t\t}\n\t\t}\n\t\treturn current\n\t}\n\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tscope: ImmerScope\n\t): void {\n\t\tif (state.scope_.processedForPatches_.has(state)) {\n\t\t\treturn\n\t\t}\n\n\t\tstate.scope_.processedForPatches_.add(state)\n\n\t\tconst {patches_, inversePatches_} = scope\n\n\t\tswitch (state.type_) {\n\t\t\tcase ArchType.Object:\n\t\t\tcase ArchType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches_!,\n\t\t\t\t\tinversePatches_!\n\t\t\t\t)\n\t\t\tcase ArchType.Array:\n\t\t\t\treturn generateArrayPatches(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches_!,\n\t\t\t\t\tinversePatches_!\n\t\t\t\t)\n\t\t\tcase ArchType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches_!,\n\t\t\t\t\tinversePatches_!\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tconst copiedItem = copy_[i]\n\t\t\tconst baseItem = base_[i]\n\t\t\tif (assigned_?.get(i.toString()) && copiedItem !== baseItem) {\n\t\t\t\tconst childState = copiedItem?.[DRAFT_STATE]\n\t\t\t\tif (childState && childState.modified_) {\n\t\t\t\t\t// Skip - let the child generate its own patches\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copiedItem)\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(baseItem)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tfor (let i = copy_.length - 1; base_.length <= i; --i) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tinversePatches.push({\n\t\t\t\top: REMOVE,\n\t\t\t\tpath\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_, type_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key, type_)\n\t\t\tconst value = get(copy_!, key, type_)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(\n\t\t\t\top === REMOVE\n\t\t\t\t\t? {op, path}\n\t\t\t\t\t: {op, path, value: clonePatchValueIfNeeded(value)}\n\t\t\t)\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tscope: ImmerScope\n\t): void {\n\t\tconst {patches_, inversePatches_} = scope\n\t\tpatches_!.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches_!.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: readonly Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tlet p = path[i]\n\t\t\t\tif (typeof p !== \"string\" && typeof p !== \"number\") {\n\t\t\t\t\tp = \"\" + p\n\t\t\t\t}\n\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === ArchType.Object || parentType === ArchType.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === CONSTRUCTOR)\n\t\t\t\t)\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tif (isFunction(base) && p === PROTOTYPE) die(errorOffset + 3)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (!isObjectish(base)) die(errorOffset + 2, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\tdie(errorOffset)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(errorOffset + 1, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(PluginPatches, {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_,\n\t\tgetPath\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tdie,\n\tArchType,\n\teach,\n\tgetValue,\n\tPluginMapSet\n} from \"../internal\"\n\nexport function enableMapSet() {\n\tclass DraftMap extends Map {\n\t\t[DRAFT_STATE]: MapState\n\n\t\tconstructor(target: AnyMap, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false,\n\t\t\t\tcallbacks_: []\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tset(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tforEach(cb: (value: any, key: any, self: any) => void, thisArg?: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tget(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(state.scope_, value, state, key)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.entries()\n\t\t}\n\t}\n\n\tfunction proxyMap_<T extends AnyMap>(\n\t\ttarget: T,\n\t\tparent?: ImmerState\n\t): [T, MapState] {\n\t\t// @ts-ignore\n\t\tconst map = new DraftMap(target, parent)\n\t\treturn [map as any, map[DRAFT_STATE]]\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tclass DraftSet extends Set {\n\t\t[DRAFT_STATE]: SetState\n\t\tconstructor(target: AnySet, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tcallbacks_: []\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tadd(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tforEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\t}\n\tfunction proxySet_<T extends AnySet>(\n\t\ttarget: T,\n\t\tparent?: ImmerState\n\t): [T, SetState] {\n\t\t// @ts-ignore\n\t\tconst set = new DraftSet(target, parent)\n\t\treturn [set as any, set[DRAFT_STATE]]\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_, value, state, value)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tfunction fixSetContents(target: ImmerState) {\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// To preserve insertion order in all cases we then clear the set\n\t\tif (target.type_ === ArchType.Set && target.copy_) {\n\t\t\tconst copy = new Set(target.copy_)\n\t\t\ttarget.copy_.clear()\n\t\t\tcopy.forEach(value => {\n\t\t\t\ttarget.copy_!.add(getValue(value))\n\t\t\t})\n\t\t}\n\t}\n\n\tloadPlugin(PluginMapSet, {proxyMap_, proxySet_, fixSetContents})\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tWritableDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\tProducer,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze,\n\tObjectish,\n\tStrictMode\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = /* @__PURE__ */ immer.produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = /* @__PURE__ */ immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = /* @__PURE__ */ immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to enable strict shallow copy.\n *\n * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n */\nexport const setUseStrictShallowCopy = /* @__PURE__ */ immer.setUseStrictShallowCopy.bind(\n\timmer\n)\n\n/**\n * Pass false to use loose iteration that only processes enumerable string properties.\n * This skips symbols and non-enumerable properties for maximum performance.\n *\n * By default, strict iteration is enabled (includes all own properties).\n */\nexport const setUseStrictIteration = /* @__PURE__ */ immer.setUseStrictIteration.bind(\n\timmer\n)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = /* @__PURE__ */ immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = /* @__PURE__ */ immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = /* @__PURE__ */ immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport let castDraft = <T>(value: T): Draft<T> => value as any\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport let castImmutable = <T>(value: T): Immutable<T> => value as any\n\nexport {Immer}\n\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}