{"ast":null,"code":"import{MAX_VALUE_REG,MIN_VALUE_REG}from'./ChartUtils';import{isNumber}from'./DataUtils';import{isWellBehavedNumber}from'./isWellBehavedNumber';export function isWellFormedNumberDomain(v){if(Array.isArray(v)&&v.length===2){var[min,max]=v;if(isWellBehavedNumber(min)&&isWellBehavedNumber(max)){return true;}}return false;}export function extendDomain(providedDomain,boundaryDomain,allowDataOverflow){if(allowDataOverflow){// If the data are allowed to overflow - we're fine with whatever user provided\nreturn providedDomain;}/*\n   * If the data are not allowed to overflow - we need to extend the domain.\n   * Means that effectively the user is allowed to make the domain larger\n   * but not smaller.\n   */return[Math.min(providedDomain[0],boundaryDomain[0]),Math.max(providedDomain[1],boundaryDomain[1])];}/**\n * So Recharts allows users to provide their own domains,\n * but it also places some expectations on what the domain is.\n * We can improve on the typescript typing, but we also need a runtime test\n to observe that the user-provided domain is well-formed,\n * that is: an array with exactly two numbers.\n *\n * This function does not accept data as an argument.\n * This is to enable a performance optimization - if the domain is there,\n * and we know what it is without traversing all the data,\n * then we don't have to traverse all the data!\n *\n * If the user-provided domain is not well-formed,\n * this function will return undefined - in which case we should traverse the data to calculate the real domain.\n *\n * This function is for parsing the numerical domain only.\n *\n * @param userDomain external prop, user provided, before validation. Can have various shapes: array, function, special magical strings inside too.\n * @param allowDataOverflow boolean, provided by users. If true then the data domain wins\n *\n * @return [min, max] domain if it's well-formed; undefined if the domain is invalid\n */export function numericalDomainSpecifiedWithoutRequiringData(userDomain,allowDataOverflow){if(!allowDataOverflow){// Cannot compute data overflow if the data is not provided\nreturn undefined;}if(typeof userDomain==='function'){// The user function expects the data to be provided as an argument\nreturn undefined;}if(Array.isArray(userDomain)&&userDomain.length===2){var[providedMin,providedMax]=userDomain;var finalMin,finalMax;if(isWellBehavedNumber(providedMin)){finalMin=providedMin;}else if(typeof providedMin==='function'){// The user function expects the data to be provided as an argument\nreturn undefined;}if(isWellBehavedNumber(providedMax)){finalMax=providedMax;}else if(typeof providedMax==='function'){// The user function expects the data to be provided as an argument\nreturn undefined;}var candidate=[finalMin,finalMax];if(isWellFormedNumberDomain(candidate)){return candidate;}}return undefined;}/**\n * So Recharts allows users to provide their own domains,\n * but it also places some expectations on what the domain is.\n * We can improve on the typescript typing, but we also need a runtime test\n * to observe that the user-provided domain is well-formed,\n * that is: an array with exactly two numbers.\n * If the user-provided domain is not well-formed,\n * this function will return undefined - in which case we should traverse the data to calculate the real domain.\n *\n * This function is for parsing the numerical domain only.\n *\n * You are probably thinking, why does domain need tick count?\n * Well it adjusts the domain based on where the \"nice ticks\" land, and nice ticks depend on the tick count.\n *\n * @param userDomain external prop, user provided, before validation. Can have various shapes: array, function, special magical strings inside too.\n * @param dataDomain calculated from data. Can be undefined, as an option for performance optimization\n * @param allowDataOverflow provided by users. If true then the data domain wins\n *\n * @return [min, max] domain if it's well-formed; undefined if the domain is invalid\n */export function parseNumericalUserDomain(userDomain,dataDomain,allowDataOverflow){if(!allowDataOverflow&&dataDomain==null){// Cannot compute data overflow if the data is not provided\nreturn undefined;}if(typeof userDomain==='function'&&dataDomain!=null){try{var result=userDomain(dataDomain,allowDataOverflow);if(isWellFormedNumberDomain(result)){return extendDomain(result,dataDomain,allowDataOverflow);}}catch(_unused){/* ignore the exception and compute domain from data later */}}if(Array.isArray(userDomain)&&userDomain.length===2){var[providedMin,providedMax]=userDomain;var finalMin,finalMax;if(providedMin==='auto'){if(dataDomain!=null){finalMin=Math.min(...dataDomain);}}else if(isNumber(providedMin)){finalMin=providedMin;}else if(typeof providedMin==='function'){try{if(dataDomain!=null){finalMin=providedMin(dataDomain===null||dataDomain===void 0?void 0:dataDomain[0]);}}catch(_unused2){/* ignore the exception and compute domain from data later */}}else if(typeof providedMin==='string'&&MIN_VALUE_REG.test(providedMin)){var match=MIN_VALUE_REG.exec(providedMin);if(match==null||dataDomain==null){finalMin=undefined;}else{var value=+match[1];finalMin=dataDomain[0]-value;}}else{finalMin=dataDomain===null||dataDomain===void 0?void 0:dataDomain[0];}if(providedMax==='auto'){if(dataDomain!=null){finalMax=Math.max(...dataDomain);}}else if(isNumber(providedMax)){finalMax=providedMax;}else if(typeof providedMax==='function'){try{if(dataDomain!=null){finalMax=providedMax(dataDomain===null||dataDomain===void 0?void 0:dataDomain[1]);}}catch(_unused3){/* ignore the exception and compute domain from data later */}}else if(typeof providedMax==='string'&&MAX_VALUE_REG.test(providedMax)){var _match=MAX_VALUE_REG.exec(providedMax);if(_match==null||dataDomain==null){finalMax=undefined;}else{var _value=+_match[1];finalMax=dataDomain[1]+_value;}}else{finalMax=dataDomain===null||dataDomain===void 0?void 0:dataDomain[1];}var candidate=[finalMin,finalMax];if(isWellFormedNumberDomain(candidate)){if(dataDomain==null){return candidate;}return extendDomain(candidate,dataDomain,allowDataOverflow);}}return undefined;}","map":{"version":3,"names":["MAX_VALUE_REG","MIN_VALUE_REG","isNumber","isWellBehavedNumber","isWellFormedNumberDomain","v","Array","isArray","length","min","max","extendDomain","providedDomain","boundaryDomain","allowDataOverflow","Math","numericalDomainSpecifiedWithoutRequiringData","userDomain","undefined","providedMin","providedMax","finalMin","finalMax","candidate","parseNumericalUserDomain","dataDomain","result","_unused","_unused2","test","match","exec","value","_unused3","_match","_value"],"sources":["E:/program/ai交友网站demo/dating-app/frontend/src/node_modules/recharts/es6/util/isDomainSpecifiedByUser.js"],"sourcesContent":["import { MAX_VALUE_REG, MIN_VALUE_REG } from './ChartUtils';\nimport { isNumber } from './DataUtils';\nimport { isWellBehavedNumber } from './isWellBehavedNumber';\nexport function isWellFormedNumberDomain(v) {\n  if (Array.isArray(v) && v.length === 2) {\n    var [min, max] = v;\n    if (isWellBehavedNumber(min) && isWellBehavedNumber(max)) {\n      return true;\n    }\n  }\n  return false;\n}\nexport function extendDomain(providedDomain, boundaryDomain, allowDataOverflow) {\n  if (allowDataOverflow) {\n    // If the data are allowed to overflow - we're fine with whatever user provided\n    return providedDomain;\n  }\n  /*\n   * If the data are not allowed to overflow - we need to extend the domain.\n   * Means that effectively the user is allowed to make the domain larger\n   * but not smaller.\n   */\n  return [Math.min(providedDomain[0], boundaryDomain[0]), Math.max(providedDomain[1], boundaryDomain[1])];\n}\n\n/**\n * So Recharts allows users to provide their own domains,\n * but it also places some expectations on what the domain is.\n * We can improve on the typescript typing, but we also need a runtime test\n to observe that the user-provided domain is well-formed,\n * that is: an array with exactly two numbers.\n *\n * This function does not accept data as an argument.\n * This is to enable a performance optimization - if the domain is there,\n * and we know what it is without traversing all the data,\n * then we don't have to traverse all the data!\n *\n * If the user-provided domain is not well-formed,\n * this function will return undefined - in which case we should traverse the data to calculate the real domain.\n *\n * This function is for parsing the numerical domain only.\n *\n * @param userDomain external prop, user provided, before validation. Can have various shapes: array, function, special magical strings inside too.\n * @param allowDataOverflow boolean, provided by users. If true then the data domain wins\n *\n * @return [min, max] domain if it's well-formed; undefined if the domain is invalid\n */\nexport function numericalDomainSpecifiedWithoutRequiringData(userDomain, allowDataOverflow) {\n  if (!allowDataOverflow) {\n    // Cannot compute data overflow if the data is not provided\n    return undefined;\n  }\n  if (typeof userDomain === 'function') {\n    // The user function expects the data to be provided as an argument\n    return undefined;\n  }\n  if (Array.isArray(userDomain) && userDomain.length === 2) {\n    var [providedMin, providedMax] = userDomain;\n    var finalMin, finalMax;\n    if (isWellBehavedNumber(providedMin)) {\n      finalMin = providedMin;\n    } else if (typeof providedMin === 'function') {\n      // The user function expects the data to be provided as an argument\n      return undefined;\n    }\n    if (isWellBehavedNumber(providedMax)) {\n      finalMax = providedMax;\n    } else if (typeof providedMax === 'function') {\n      // The user function expects the data to be provided as an argument\n      return undefined;\n    }\n    var candidate = [finalMin, finalMax];\n    if (isWellFormedNumberDomain(candidate)) {\n      return candidate;\n    }\n  }\n  return undefined;\n}\n\n/**\n * So Recharts allows users to provide their own domains,\n * but it also places some expectations on what the domain is.\n * We can improve on the typescript typing, but we also need a runtime test\n * to observe that the user-provided domain is well-formed,\n * that is: an array with exactly two numbers.\n * If the user-provided domain is not well-formed,\n * this function will return undefined - in which case we should traverse the data to calculate the real domain.\n *\n * This function is for parsing the numerical domain only.\n *\n * You are probably thinking, why does domain need tick count?\n * Well it adjusts the domain based on where the \"nice ticks\" land, and nice ticks depend on the tick count.\n *\n * @param userDomain external prop, user provided, before validation. Can have various shapes: array, function, special magical strings inside too.\n * @param dataDomain calculated from data. Can be undefined, as an option for performance optimization\n * @param allowDataOverflow provided by users. If true then the data domain wins\n *\n * @return [min, max] domain if it's well-formed; undefined if the domain is invalid\n */\nexport function parseNumericalUserDomain(userDomain, dataDomain, allowDataOverflow) {\n  if (!allowDataOverflow && dataDomain == null) {\n    // Cannot compute data overflow if the data is not provided\n    return undefined;\n  }\n  if (typeof userDomain === 'function' && dataDomain != null) {\n    try {\n      var result = userDomain(dataDomain, allowDataOverflow);\n      if (isWellFormedNumberDomain(result)) {\n        return extendDomain(result, dataDomain, allowDataOverflow);\n      }\n    } catch (_unused) {\n      /* ignore the exception and compute domain from data later */\n    }\n  }\n  if (Array.isArray(userDomain) && userDomain.length === 2) {\n    var [providedMin, providedMax] = userDomain;\n    var finalMin, finalMax;\n    if (providedMin === 'auto') {\n      if (dataDomain != null) {\n        finalMin = Math.min(...dataDomain);\n      }\n    } else if (isNumber(providedMin)) {\n      finalMin = providedMin;\n    } else if (typeof providedMin === 'function') {\n      try {\n        if (dataDomain != null) {\n          finalMin = providedMin(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0]);\n        }\n      } catch (_unused2) {\n        /* ignore the exception and compute domain from data later */\n      }\n    } else if (typeof providedMin === 'string' && MIN_VALUE_REG.test(providedMin)) {\n      var match = MIN_VALUE_REG.exec(providedMin);\n      if (match == null || dataDomain == null) {\n        finalMin = undefined;\n      } else {\n        var value = +match[1];\n        finalMin = dataDomain[0] - value;\n      }\n    } else {\n      finalMin = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0];\n    }\n    if (providedMax === 'auto') {\n      if (dataDomain != null) {\n        finalMax = Math.max(...dataDomain);\n      }\n    } else if (isNumber(providedMax)) {\n      finalMax = providedMax;\n    } else if (typeof providedMax === 'function') {\n      try {\n        if (dataDomain != null) {\n          finalMax = providedMax(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1]);\n        }\n      } catch (_unused3) {\n        /* ignore the exception and compute domain from data later */\n      }\n    } else if (typeof providedMax === 'string' && MAX_VALUE_REG.test(providedMax)) {\n      var _match = MAX_VALUE_REG.exec(providedMax);\n      if (_match == null || dataDomain == null) {\n        finalMax = undefined;\n      } else {\n        var _value = +_match[1];\n        finalMax = dataDomain[1] + _value;\n      }\n    } else {\n      finalMax = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1];\n    }\n    var candidate = [finalMin, finalMax];\n    if (isWellFormedNumberDomain(candidate)) {\n      if (dataDomain == null) {\n        return candidate;\n      }\n      return extendDomain(candidate, dataDomain, allowDataOverflow);\n    }\n  }\n  return undefined;\n}"],"mappings":"AAAA,OAASA,aAAa,CAAEC,aAAa,KAAQ,cAAc,CAC3D,OAASC,QAAQ,KAAQ,aAAa,CACtC,OAASC,mBAAmB,KAAQ,uBAAuB,CAC3D,MAAO,SAAS,CAAAC,wBAAwBA,CAACC,CAAC,CAAE,CAC1C,GAAIC,KAAK,CAACC,OAAO,CAACF,CAAC,CAAC,EAAIA,CAAC,CAACG,MAAM,GAAK,CAAC,CAAE,CACtC,GAAI,CAACC,GAAG,CAAEC,GAAG,CAAC,CAAGL,CAAC,CAClB,GAAIF,mBAAmB,CAACM,GAAG,CAAC,EAAIN,mBAAmB,CAACO,GAAG,CAAC,CAAE,CACxD,MAAO,KAAI,CACb,CACF,CACA,MAAO,MAAK,CACd,CACA,MAAO,SAAS,CAAAC,YAAYA,CAACC,cAAc,CAAEC,cAAc,CAAEC,iBAAiB,CAAE,CAC9E,GAAIA,iBAAiB,CAAE,CACrB;AACA,MAAO,CAAAF,cAAc,CACvB,CACA;AACF;AACA;AACA;AACA,KACE,MAAO,CAACG,IAAI,CAACN,GAAG,CAACG,cAAc,CAAC,CAAC,CAAC,CAAEC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAEE,IAAI,CAACL,GAAG,CAACE,cAAc,CAAC,CAAC,CAAC,CAAEC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CACzG,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAAG,4CAA4CA,CAACC,UAAU,CAAEH,iBAAiB,CAAE,CAC1F,GAAI,CAACA,iBAAiB,CAAE,CACtB;AACA,MAAO,CAAAI,SAAS,CAClB,CACA,GAAI,MAAO,CAAAD,UAAU,GAAK,UAAU,CAAE,CACpC;AACA,MAAO,CAAAC,SAAS,CAClB,CACA,GAAIZ,KAAK,CAACC,OAAO,CAACU,UAAU,CAAC,EAAIA,UAAU,CAACT,MAAM,GAAK,CAAC,CAAE,CACxD,GAAI,CAACW,WAAW,CAAEC,WAAW,CAAC,CAAGH,UAAU,CAC3C,GAAI,CAAAI,QAAQ,CAAEC,QAAQ,CACtB,GAAInB,mBAAmB,CAACgB,WAAW,CAAC,CAAE,CACpCE,QAAQ,CAAGF,WAAW,CACxB,CAAC,IAAM,IAAI,MAAO,CAAAA,WAAW,GAAK,UAAU,CAAE,CAC5C;AACA,MAAO,CAAAD,SAAS,CAClB,CACA,GAAIf,mBAAmB,CAACiB,WAAW,CAAC,CAAE,CACpCE,QAAQ,CAAGF,WAAW,CACxB,CAAC,IAAM,IAAI,MAAO,CAAAA,WAAW,GAAK,UAAU,CAAE,CAC5C;AACA,MAAO,CAAAF,SAAS,CAClB,CACA,GAAI,CAAAK,SAAS,CAAG,CAACF,QAAQ,CAAEC,QAAQ,CAAC,CACpC,GAAIlB,wBAAwB,CAACmB,SAAS,CAAC,CAAE,CACvC,MAAO,CAAAA,SAAS,CAClB,CACF,CACA,MAAO,CAAAL,SAAS,CAClB,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAAM,wBAAwBA,CAACP,UAAU,CAAEQ,UAAU,CAAEX,iBAAiB,CAAE,CAClF,GAAI,CAACA,iBAAiB,EAAIW,UAAU,EAAI,IAAI,CAAE,CAC5C;AACA,MAAO,CAAAP,SAAS,CAClB,CACA,GAAI,MAAO,CAAAD,UAAU,GAAK,UAAU,EAAIQ,UAAU,EAAI,IAAI,CAAE,CAC1D,GAAI,CACF,GAAI,CAAAC,MAAM,CAAGT,UAAU,CAACQ,UAAU,CAAEX,iBAAiB,CAAC,CACtD,GAAIV,wBAAwB,CAACsB,MAAM,CAAC,CAAE,CACpC,MAAO,CAAAf,YAAY,CAACe,MAAM,CAAED,UAAU,CAAEX,iBAAiB,CAAC,CAC5D,CACF,CAAE,MAAOa,OAAO,CAAE,CAChB,8DAEJ,CACA,GAAIrB,KAAK,CAACC,OAAO,CAACU,UAAU,CAAC,EAAIA,UAAU,CAACT,MAAM,GAAK,CAAC,CAAE,CACxD,GAAI,CAACW,WAAW,CAAEC,WAAW,CAAC,CAAGH,UAAU,CAC3C,GAAI,CAAAI,QAAQ,CAAEC,QAAQ,CACtB,GAAIH,WAAW,GAAK,MAAM,CAAE,CAC1B,GAAIM,UAAU,EAAI,IAAI,CAAE,CACtBJ,QAAQ,CAAGN,IAAI,CAACN,GAAG,CAAC,GAAGgB,UAAU,CAAC,CACpC,CACF,CAAC,IAAM,IAAIvB,QAAQ,CAACiB,WAAW,CAAC,CAAE,CAChCE,QAAQ,CAAGF,WAAW,CACxB,CAAC,IAAM,IAAI,MAAO,CAAAA,WAAW,GAAK,UAAU,CAAE,CAC5C,GAAI,CACF,GAAIM,UAAU,EAAI,IAAI,CAAE,CACtBJ,QAAQ,CAAGF,WAAW,CAACM,UAAU,GAAK,IAAI,EAAIA,UAAU,GAAK,IAAK,EAAC,CAAG,IAAK,EAAC,CAAGA,UAAU,CAAC,CAAC,CAAC,CAAC,CAC/F,CACF,CAAE,MAAOG,QAAQ,CAAE,CACjB,8DAEJ,CAAC,IAAM,IAAI,MAAO,CAAAT,WAAW,GAAK,QAAQ,EAAIlB,aAAa,CAAC4B,IAAI,CAACV,WAAW,CAAC,CAAE,CAC7E,GAAI,CAAAW,KAAK,CAAG7B,aAAa,CAAC8B,IAAI,CAACZ,WAAW,CAAC,CAC3C,GAAIW,KAAK,EAAI,IAAI,EAAIL,UAAU,EAAI,IAAI,CAAE,CACvCJ,QAAQ,CAAGH,SAAS,CACtB,CAAC,IAAM,CACL,GAAI,CAAAc,KAAK,CAAG,CAACF,KAAK,CAAC,CAAC,CAAC,CACrBT,QAAQ,CAAGI,UAAU,CAAC,CAAC,CAAC,CAAGO,KAAK,CAClC,CACF,CAAC,IAAM,CACLX,QAAQ,CAAGI,UAAU,GAAK,IAAI,EAAIA,UAAU,GAAK,IAAK,EAAC,CAAG,IAAK,EAAC,CAAGA,UAAU,CAAC,CAAC,CAAC,CAClF,CACA,GAAIL,WAAW,GAAK,MAAM,CAAE,CAC1B,GAAIK,UAAU,EAAI,IAAI,CAAE,CACtBH,QAAQ,CAAGP,IAAI,CAACL,GAAG,CAAC,GAAGe,UAAU,CAAC,CACpC,CACF,CAAC,IAAM,IAAIvB,QAAQ,CAACkB,WAAW,CAAC,CAAE,CAChCE,QAAQ,CAAGF,WAAW,CACxB,CAAC,IAAM,IAAI,MAAO,CAAAA,WAAW,GAAK,UAAU,CAAE,CAC5C,GAAI,CACF,GAAIK,UAAU,EAAI,IAAI,CAAE,CACtBH,QAAQ,CAAGF,WAAW,CAACK,UAAU,GAAK,IAAI,EAAIA,UAAU,GAAK,IAAK,EAAC,CAAG,IAAK,EAAC,CAAGA,UAAU,CAAC,CAAC,CAAC,CAAC,CAC/F,CACF,CAAE,MAAOQ,QAAQ,CAAE,CACjB,8DAEJ,CAAC,IAAM,IAAI,MAAO,CAAAb,WAAW,GAAK,QAAQ,EAAIpB,aAAa,CAAC6B,IAAI,CAACT,WAAW,CAAC,CAAE,CAC7E,GAAI,CAAAc,MAAM,CAAGlC,aAAa,CAAC+B,IAAI,CAACX,WAAW,CAAC,CAC5C,GAAIc,MAAM,EAAI,IAAI,EAAIT,UAAU,EAAI,IAAI,CAAE,CACxCH,QAAQ,CAAGJ,SAAS,CACtB,CAAC,IAAM,CACL,GAAI,CAAAiB,MAAM,CAAG,CAACD,MAAM,CAAC,CAAC,CAAC,CACvBZ,QAAQ,CAAGG,UAAU,CAAC,CAAC,CAAC,CAAGU,MAAM,CACnC,CACF,CAAC,IAAM,CACLb,QAAQ,CAAGG,UAAU,GAAK,IAAI,EAAIA,UAAU,GAAK,IAAK,EAAC,CAAG,IAAK,EAAC,CAAGA,UAAU,CAAC,CAAC,CAAC,CAClF,CACA,GAAI,CAAAF,SAAS,CAAG,CAACF,QAAQ,CAAEC,QAAQ,CAAC,CACpC,GAAIlB,wBAAwB,CAACmB,SAAS,CAAC,CAAE,CACvC,GAAIE,UAAU,EAAI,IAAI,CAAE,CACtB,MAAO,CAAAF,SAAS,CAClB,CACA,MAAO,CAAAZ,YAAY,CAACY,SAAS,CAAEE,UAAU,CAAEX,iBAAiB,CAAC,CAC/D,CACF,CACA,MAAO,CAAAI,SAAS,CAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}