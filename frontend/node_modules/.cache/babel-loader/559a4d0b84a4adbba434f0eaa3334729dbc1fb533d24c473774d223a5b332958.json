{"ast":null,"code":"import{memo,useLayoutEffect,useRef}from'react';import{useAppDispatch}from'./hooks';import{addCartesianGraphicalItem,addPolarGraphicalItem,removeCartesianGraphicalItem,removePolarGraphicalItem,replaceCartesianGraphicalItem}from'./graphicalItemsSlice';var SetCartesianGraphicalItemImpl=props=>{var dispatch=useAppDispatch();var prevPropsRef=useRef(null);useLayoutEffect(()=>{if(prevPropsRef.current===null){dispatch(addCartesianGraphicalItem(props));}else if(prevPropsRef.current!==props){dispatch(replaceCartesianGraphicalItem({prev:prevPropsRef.current,next:props}));}prevPropsRef.current=props;},[dispatch,props]);useLayoutEffect(()=>{return()=>{if(prevPropsRef.current){dispatch(removeCartesianGraphicalItem(prevPropsRef.current));/*\n         * Here we have to reset the ref to null because in StrictMode, the effect will run twice,\n         * but it will keep the same ref value from the first render.\n         *\n         * In browser, React will clear the ref after the first effect cleanup,\n         * so that wouldn't be an issue.\n         *\n         * In StrictMode, however, the ref is kept,\n         * and in the hook above the code checks for `prevPropsRef.current === null`\n         * which would be false so it would not dispatch the `addCartesianGraphicalItem` action again.\n         *\n         * https://github.com/recharts/recharts/issues/6022\n         */prevPropsRef.current=null;}};},[dispatch]);return null;};export var SetCartesianGraphicalItem=/*#__PURE__*/memo(SetCartesianGraphicalItemImpl);export function SetPolarGraphicalItem(props){var dispatch=useAppDispatch();useLayoutEffect(()=>{dispatch(addPolarGraphicalItem(props));return()=>{dispatch(removePolarGraphicalItem(props));};},[dispatch,props]);return null;}","map":{"version":3,"names":["memo","useLayoutEffect","useRef","useAppDispatch","addCartesianGraphicalItem","addPolarGraphicalItem","removeCartesianGraphicalItem","removePolarGraphicalItem","replaceCartesianGraphicalItem","SetCartesianGraphicalItemImpl","props","dispatch","prevPropsRef","current","prev","next","SetCartesianGraphicalItem","SetPolarGraphicalItem"],"sources":["E:/program/ai交友网站demo/dating-app/frontend/src/node_modules/recharts/es6/state/SetGraphicalItem.js"],"sourcesContent":["import { memo, useLayoutEffect, useRef } from 'react';\nimport { useAppDispatch } from './hooks';\nimport { addCartesianGraphicalItem, addPolarGraphicalItem, removeCartesianGraphicalItem, removePolarGraphicalItem, replaceCartesianGraphicalItem } from './graphicalItemsSlice';\nvar SetCartesianGraphicalItemImpl = props => {\n  var dispatch = useAppDispatch();\n  var prevPropsRef = useRef(null);\n  useLayoutEffect(() => {\n    if (prevPropsRef.current === null) {\n      dispatch(addCartesianGraphicalItem(props));\n    } else if (prevPropsRef.current !== props) {\n      dispatch(replaceCartesianGraphicalItem({\n        prev: prevPropsRef.current,\n        next: props\n      }));\n    }\n    prevPropsRef.current = props;\n  }, [dispatch, props]);\n  useLayoutEffect(() => {\n    return () => {\n      if (prevPropsRef.current) {\n        dispatch(removeCartesianGraphicalItem(prevPropsRef.current));\n        /*\n         * Here we have to reset the ref to null because in StrictMode, the effect will run twice,\n         * but it will keep the same ref value from the first render.\n         *\n         * In browser, React will clear the ref after the first effect cleanup,\n         * so that wouldn't be an issue.\n         *\n         * In StrictMode, however, the ref is kept,\n         * and in the hook above the code checks for `prevPropsRef.current === null`\n         * which would be false so it would not dispatch the `addCartesianGraphicalItem` action again.\n         *\n         * https://github.com/recharts/recharts/issues/6022\n         */\n        prevPropsRef.current = null;\n      }\n    };\n  }, [dispatch]);\n  return null;\n};\nexport var SetCartesianGraphicalItem = /*#__PURE__*/memo(SetCartesianGraphicalItemImpl);\nexport function SetPolarGraphicalItem(props) {\n  var dispatch = useAppDispatch();\n  useLayoutEffect(() => {\n    dispatch(addPolarGraphicalItem(props));\n    return () => {\n      dispatch(removePolarGraphicalItem(props));\n    };\n  }, [dispatch, props]);\n  return null;\n}"],"mappings":"AAAA,OAASA,IAAI,CAAEC,eAAe,CAAEC,MAAM,KAAQ,OAAO,CACrD,OAASC,cAAc,KAAQ,SAAS,CACxC,OAASC,yBAAyB,CAAEC,qBAAqB,CAAEC,4BAA4B,CAAEC,wBAAwB,CAAEC,6BAA6B,KAAQ,uBAAuB,CAC/K,GAAI,CAAAC,6BAA6B,CAAGC,KAAK,EAAI,CAC3C,GAAI,CAAAC,QAAQ,CAAGR,cAAc,CAAC,CAAC,CAC/B,GAAI,CAAAS,YAAY,CAAGV,MAAM,CAAC,IAAI,CAAC,CAC/BD,eAAe,CAAC,IAAM,CACpB,GAAIW,YAAY,CAACC,OAAO,GAAK,IAAI,CAAE,CACjCF,QAAQ,CAACP,yBAAyB,CAACM,KAAK,CAAC,CAAC,CAC5C,CAAC,IAAM,IAAIE,YAAY,CAACC,OAAO,GAAKH,KAAK,CAAE,CACzCC,QAAQ,CAACH,6BAA6B,CAAC,CACrCM,IAAI,CAAEF,YAAY,CAACC,OAAO,CAC1BE,IAAI,CAAEL,KACR,CAAC,CAAC,CAAC,CACL,CACAE,YAAY,CAACC,OAAO,CAAGH,KAAK,CAC9B,CAAC,CAAE,CAACC,QAAQ,CAAED,KAAK,CAAC,CAAC,CACrBT,eAAe,CAAC,IAAM,CACpB,MAAO,IAAM,CACX,GAAIW,YAAY,CAACC,OAAO,CAAE,CACxBF,QAAQ,CAACL,4BAA4B,CAACM,YAAY,CAACC,OAAO,CAAC,CAAC,CAC5D;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WACQD,YAAY,CAACC,OAAO,CAAG,IAAI,CAC7B,CACF,CAAC,CACH,CAAC,CAAE,CAACF,QAAQ,CAAC,CAAC,CACd,MAAO,KAAI,CACb,CAAC,CACD,MAAO,IAAI,CAAAK,yBAAyB,CAAG,aAAahB,IAAI,CAACS,6BAA6B,CAAC,CACvF,MAAO,SAAS,CAAAQ,qBAAqBA,CAACP,KAAK,CAAE,CAC3C,GAAI,CAAAC,QAAQ,CAAGR,cAAc,CAAC,CAAC,CAC/BF,eAAe,CAAC,IAAM,CACpBU,QAAQ,CAACN,qBAAqB,CAACK,KAAK,CAAC,CAAC,CACtC,MAAO,IAAM,CACXC,QAAQ,CAACJ,wBAAwB,CAACG,KAAK,CAAC,CAAC,CAC3C,CAAC,CACH,CAAC,CAAE,CAACC,QAAQ,CAAED,KAAK,CAAC,CAAC,CACrB,MAAO,KAAI,CACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}