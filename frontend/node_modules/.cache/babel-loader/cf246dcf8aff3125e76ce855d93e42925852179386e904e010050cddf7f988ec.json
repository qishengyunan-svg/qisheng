{"ast":null,"code":"/**\n * @fileOverview calculate tick values of scale\n * @author xile611, arcthur\n * @date 2015-09-17\n */import Decimal from'decimal.js-light';import{compose,range,map,reverse}from'./util/utils';import{getDigitCount,rangeStep}from'./util/arithmetic';/**\n * Calculate a interval of a minimum value and a maximum value\n *\n * @param  {Number} min       The minimum value\n * @param  {Number} max       The maximum value\n * @return {Array} An interval\n */export var getValidInterval=_ref=>{var[min,max]=_ref;var[validMin,validMax]=[min,max];// exchange\nif(min>max){[validMin,validMax]=[max,min];}return[validMin,validMax];};/**\n * Calculate the step which is easy to understand between ticks, like 10, 20, 25\n *\n * @param  roughStep        The rough step calculated by dividing the difference by the tickCount\n * @param  allowDecimals    Allow the ticks to be decimals or not\n * @param  correctionFactor A correction factor\n * @return The step which is easy to understand between two ticks\n */export var getFormatStep=(roughStep,allowDecimals,correctionFactor)=>{if(roughStep.lte(0)){return new Decimal(0);}var digitCount=getDigitCount(roughStep.toNumber());// The ratio between the rough step and the smallest number which has a bigger\n// order of magnitudes than the rough step\nvar digitCountValue=new Decimal(10).pow(digitCount);var stepRatio=roughStep.div(digitCountValue);// When an integer and a float multiplied, the accuracy of result may be wrong\nvar stepRatioScale=digitCount!==1?0.05:0.1;var amendStepRatio=new Decimal(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);var formatStep=amendStepRatio.mul(digitCountValue);return allowDecimals?new Decimal(formatStep.toNumber()):new Decimal(Math.ceil(formatStep.toNumber()));};/**\n * calculate the ticks when the minimum value equals to the maximum value\n *\n * @param  value         The minimum value which is also the maximum value\n * @param  tickCount     The count of ticks\n * @param  allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */export var getTickOfSingleValue=(value,tickCount,allowDecimals)=>{var step=new Decimal(1);// calculate the middle value of ticks\nvar middle=new Decimal(value);if(!middle.isint()&&allowDecimals){var absVal=Math.abs(value);if(absVal<1){// The step should be a float number when the difference is smaller than 1\nstep=new Decimal(10).pow(getDigitCount(value)-1);middle=new Decimal(Math.floor(middle.div(step).toNumber())).mul(step);}else if(absVal>1){// Return the maximum integer which is smaller than 'value' when 'value' is greater than 1\nmiddle=new Decimal(Math.floor(value));}}else if(value===0){middle=new Decimal(Math.floor((tickCount-1)/2));}else if(!allowDecimals){middle=new Decimal(Math.floor(value));}var middleIndex=Math.floor((tickCount-1)/2);var fn=compose(map(n=>middle.add(new Decimal(n-middleIndex).mul(step)).toNumber()),range);return fn(0,tickCount);};/**\n * Calculate the step\n *\n * @param  min              The minimum value of an interval\n * @param  max              The maximum value of an interval\n * @param  tickCount        The count of ticks\n * @param  allowDecimals    Allow the ticks to be decimals or not\n * @param  correctionFactor A correction factor\n * @return The step, minimum value of ticks, maximum value of ticks\n */var _calculateStep=function calculateStep(min,max,tickCount,allowDecimals){var correctionFactor=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;// dirty hack (for recharts' test)\nif(!Number.isFinite((max-min)/(tickCount-1))){return{step:new Decimal(0),tickMin:new Decimal(0),tickMax:new Decimal(0)};}// The step which is easy to understand between two ticks\nvar step=getFormatStep(new Decimal(max).sub(min).div(tickCount-1),allowDecimals,correctionFactor);// A medial value of ticks\nvar middle;// When 0 is inside the interval, 0 should be a tick\nif(min<=0&&max>=0){middle=new Decimal(0);}else{// calculate the middle value\nmiddle=new Decimal(min).add(max).div(2);// minus modulo value\nmiddle=middle.sub(new Decimal(middle).mod(step));}var belowCount=Math.ceil(middle.sub(min).div(step).toNumber());var upCount=Math.ceil(new Decimal(max).sub(middle).div(step).toNumber());var scaleCount=belowCount+upCount+1;if(scaleCount>tickCount){// When more ticks need to cover the interval, step should be bigger.\nreturn _calculateStep(min,max,tickCount,allowDecimals,correctionFactor+1);}if(scaleCount<tickCount){// When less ticks can cover the interval, we should add some additional ticks\nupCount=max>0?upCount+(tickCount-scaleCount):upCount;belowCount=max>0?belowCount:belowCount+(tickCount-scaleCount);}return{step,tickMin:middle.sub(new Decimal(belowCount).mul(step)),tickMax:middle.add(new Decimal(upCount).mul(step))};};/**\n * Calculate the ticks of an interval. Ticks can appear outside the interval\n * if it makes them more rounded and nice.\n *\n * @param tuple of [min,max] min: The minimum value, max: The maximum value\n * @param tickCount     The count of ticks\n * @param allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */export{_calculateStep as calculateStep};export var getNiceTickValues=function getNiceTickValues(_ref2){var[min,max]=_ref2;var tickCount=arguments.length>1&&arguments[1]!==undefined?arguments[1]:6;var allowDecimals=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;// More than two ticks should be return\nvar count=Math.max(tickCount,2);var[cormin,cormax]=getValidInterval([min,max]);if(cormin===-Infinity||cormax===Infinity){var _values=cormax===Infinity?[cormin,...range(0,tickCount-1).map(()=>Infinity)]:[...range(0,tickCount-1).map(()=>-Infinity),cormax];return min>max?reverse(_values):_values;}if(cormin===cormax){return getTickOfSingleValue(cormin,tickCount,allowDecimals);}// Get the step between two ticks\nvar{step,tickMin,tickMax}=_calculateStep(cormin,cormax,count,allowDecimals,0);var values=rangeStep(tickMin,tickMax.add(new Decimal(0.1).mul(step)),step);return min>max?reverse(values):values;};/**\n * Calculate the ticks of an interval.\n * Ticks will be constrained to the interval [min, max] even if it makes them less rounded and nice.\n *\n * @param tuple of [min,max] min: The minimum value, max: The maximum value\n * @param tickCount     The count of ticks. This function may return less than tickCount ticks if the interval is too small.\n * @param allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */export var getTickValuesFixedDomain=function getTickValuesFixedDomain(_ref3,tickCount){var[min,max]=_ref3;var allowDecimals=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;// More than two ticks should be return\nvar[cormin,cormax]=getValidInterval([min,max]);if(cormin===-Infinity||cormax===Infinity){return[min,max];}if(cormin===cormax){return[cormin];}var count=Math.max(tickCount,2);var step=getFormatStep(new Decimal(cormax).sub(cormin).div(count-1),allowDecimals,0);var values=[...rangeStep(new Decimal(cormin),new Decimal(cormax),step),cormax];if(allowDecimals===false){/*\n     * allowDecimals is false means that we want to have integer ticks.\n     * The step is guaranteed to be an integer in the code above which is great start\n     * but when the first step is not an integer, it will start stepping from a decimal value anyway.\n     * So we need to round all the values to integers after the fact.\n     */values=values.map(value=>Math.round(value));}return min>max?reverse(values):values;};","map":{"version":3,"names":["Decimal","compose","range","map","reverse","getDigitCount","rangeStep","getValidInterval","_ref","min","max","validMin","validMax","getFormatStep","roughStep","allowDecimals","correctionFactor","lte","digitCount","toNumber","digitCountValue","pow","stepRatio","div","stepRatioScale","amendStepRatio","Math","ceil","add","mul","formatStep","getTickOfSingleValue","value","tickCount","step","middle","isint","absVal","abs","floor","middleIndex","fn","n","_calculateStep","calculateStep","arguments","length","undefined","Number","isFinite","tickMin","tickMax","sub","mod","belowCount","upCount","scaleCount","getNiceTickValues","_ref2","count","cormin","cormax","Infinity","_values","values","getTickValuesFixedDomain","_ref3","round"],"sources":["E:/program/ai交友网站demo/dating-app/frontend/src/node_modules/recharts/es6/util/scale/getNiceTickValues.js"],"sourcesContent":["/**\n * @fileOverview calculate tick values of scale\n * @author xile611, arcthur\n * @date 2015-09-17\n */\nimport Decimal from 'decimal.js-light';\nimport { compose, range, map, reverse } from './util/utils';\nimport { getDigitCount, rangeStep } from './util/arithmetic';\n/**\n * Calculate a interval of a minimum value and a maximum value\n *\n * @param  {Number} min       The minimum value\n * @param  {Number} max       The maximum value\n * @return {Array} An interval\n */\nexport var getValidInterval = _ref => {\n  var [min, max] = _ref;\n  var [validMin, validMax] = [min, max];\n\n  // exchange\n  if (min > max) {\n    [validMin, validMax] = [max, min];\n  }\n  return [validMin, validMax];\n};\n\n/**\n * Calculate the step which is easy to understand between ticks, like 10, 20, 25\n *\n * @param  roughStep        The rough step calculated by dividing the difference by the tickCount\n * @param  allowDecimals    Allow the ticks to be decimals or not\n * @param  correctionFactor A correction factor\n * @return The step which is easy to understand between two ticks\n */\nexport var getFormatStep = (roughStep, allowDecimals, correctionFactor) => {\n  if (roughStep.lte(0)) {\n    return new Decimal(0);\n  }\n  var digitCount = getDigitCount(roughStep.toNumber());\n  // The ratio between the rough step and the smallest number which has a bigger\n  // order of magnitudes than the rough step\n  var digitCountValue = new Decimal(10).pow(digitCount);\n  var stepRatio = roughStep.div(digitCountValue);\n  // When an integer and a float multiplied, the accuracy of result may be wrong\n  var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;\n  var amendStepRatio = new Decimal(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);\n  var formatStep = amendStepRatio.mul(digitCountValue);\n  return allowDecimals ? new Decimal(formatStep.toNumber()) : new Decimal(Math.ceil(formatStep.toNumber()));\n};\n\n/**\n * calculate the ticks when the minimum value equals to the maximum value\n *\n * @param  value         The minimum value which is also the maximum value\n * @param  tickCount     The count of ticks\n * @param  allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\nexport var getTickOfSingleValue = (value, tickCount, allowDecimals) => {\n  var step = new Decimal(1);\n  // calculate the middle value of ticks\n  var middle = new Decimal(value);\n  if (!middle.isint() && allowDecimals) {\n    var absVal = Math.abs(value);\n    if (absVal < 1) {\n      // The step should be a float number when the difference is smaller than 1\n      step = new Decimal(10).pow(getDigitCount(value) - 1);\n      middle = new Decimal(Math.floor(middle.div(step).toNumber())).mul(step);\n    } else if (absVal > 1) {\n      // Return the maximum integer which is smaller than 'value' when 'value' is greater than 1\n      middle = new Decimal(Math.floor(value));\n    }\n  } else if (value === 0) {\n    middle = new Decimal(Math.floor((tickCount - 1) / 2));\n  } else if (!allowDecimals) {\n    middle = new Decimal(Math.floor(value));\n  }\n  var middleIndex = Math.floor((tickCount - 1) / 2);\n  var fn = compose(map(n => middle.add(new Decimal(n - middleIndex).mul(step)).toNumber()), range);\n  return fn(0, tickCount);\n};\n\n/**\n * Calculate the step\n *\n * @param  min              The minimum value of an interval\n * @param  max              The maximum value of an interval\n * @param  tickCount        The count of ticks\n * @param  allowDecimals    Allow the ticks to be decimals or not\n * @param  correctionFactor A correction factor\n * @return The step, minimum value of ticks, maximum value of ticks\n */\nvar _calculateStep = function calculateStep(min, max, tickCount, allowDecimals) {\n  var correctionFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  // dirty hack (for recharts' test)\n  if (!Number.isFinite((max - min) / (tickCount - 1))) {\n    return {\n      step: new Decimal(0),\n      tickMin: new Decimal(0),\n      tickMax: new Decimal(0)\n    };\n  }\n\n  // The step which is easy to understand between two ticks\n  var step = getFormatStep(new Decimal(max).sub(min).div(tickCount - 1), allowDecimals, correctionFactor);\n\n  // A medial value of ticks\n  var middle;\n\n  // When 0 is inside the interval, 0 should be a tick\n  if (min <= 0 && max >= 0) {\n    middle = new Decimal(0);\n  } else {\n    // calculate the middle value\n    middle = new Decimal(min).add(max).div(2);\n    // minus modulo value\n    middle = middle.sub(new Decimal(middle).mod(step));\n  }\n  var belowCount = Math.ceil(middle.sub(min).div(step).toNumber());\n  var upCount = Math.ceil(new Decimal(max).sub(middle).div(step).toNumber());\n  var scaleCount = belowCount + upCount + 1;\n  if (scaleCount > tickCount) {\n    // When more ticks need to cover the interval, step should be bigger.\n    return _calculateStep(min, max, tickCount, allowDecimals, correctionFactor + 1);\n  }\n  if (scaleCount < tickCount) {\n    // When less ticks can cover the interval, we should add some additional ticks\n    upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount;\n    belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount);\n  }\n  return {\n    step,\n    tickMin: middle.sub(new Decimal(belowCount).mul(step)),\n    tickMax: middle.add(new Decimal(upCount).mul(step))\n  };\n};\n\n/**\n * Calculate the ticks of an interval. Ticks can appear outside the interval\n * if it makes them more rounded and nice.\n *\n * @param tuple of [min,max] min: The minimum value, max: The maximum value\n * @param tickCount     The count of ticks\n * @param allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\nexport { _calculateStep as calculateStep };\nexport var getNiceTickValues = function getNiceTickValues(_ref2) {\n  var [min, max] = _ref2;\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // More than two ticks should be return\n  var count = Math.max(tickCount, 2);\n  var [cormin, cormax] = getValidInterval([min, max]);\n  if (cormin === -Infinity || cormax === Infinity) {\n    var _values = cormax === Infinity ? [cormin, ...range(0, tickCount - 1).map(() => Infinity)] : [...range(0, tickCount - 1).map(() => -Infinity), cormax];\n    return min > max ? reverse(_values) : _values;\n  }\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  }\n\n  // Get the step between two ticks\n  var {\n    step,\n    tickMin,\n    tickMax\n  } = _calculateStep(cormin, cormax, count, allowDecimals, 0);\n  var values = rangeStep(tickMin, tickMax.add(new Decimal(0.1).mul(step)), step);\n  return min > max ? reverse(values) : values;\n};\n\n/**\n * Calculate the ticks of an interval.\n * Ticks will be constrained to the interval [min, max] even if it makes them less rounded and nice.\n *\n * @param tuple of [min,max] min: The minimum value, max: The maximum value\n * @param tickCount     The count of ticks. This function may return less than tickCount ticks if the interval is too small.\n * @param allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\nexport var getTickValuesFixedDomain = function getTickValuesFixedDomain(_ref3, tickCount) {\n  var [min, max] = _ref3;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // More than two ticks should be return\n  var [cormin, cormax] = getValidInterval([min, max]);\n  if (cormin === -Infinity || cormax === Infinity) {\n    return [min, max];\n  }\n  if (cormin === cormax) {\n    return [cormin];\n  }\n  var count = Math.max(tickCount, 2);\n  var step = getFormatStep(new Decimal(cormax).sub(cormin).div(count - 1), allowDecimals, 0);\n  var values = [...rangeStep(new Decimal(cormin), new Decimal(cormax), step), cormax];\n  if (allowDecimals === false) {\n    /*\n     * allowDecimals is false means that we want to have integer ticks.\n     * The step is guaranteed to be an integer in the code above which is great start\n     * but when the first step is not an integer, it will start stepping from a decimal value anyway.\n     * So we need to round all the values to integers after the fact.\n     */\n    values = values.map(value => Math.round(value));\n  }\n  return min > max ? reverse(values) : values;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}