{"ast":null,"code":"import{isValidElement}from'react';import{isEventKey}from'./excludeEventProps';/**\n * Determines how values are stacked:\n *\n * - `none` is the default, it adds values on top of each other. No smarts. Negative values will overlap.\n * - `expand` make it so that the values always add up to 1 - so the chart will look like a rectangle.\n * - `wiggle` and `silhouette` tries to keep the chart centered.\n * - `sign` stacks positive values above zero and negative values below zero. Similar to `none` but handles negatives.\n * - `positive` ignores all negative values, and then behaves like \\`none\\`.\n *\n * Also see https://d3js.org/d3-shape/stack#stack-offsets\n * (note that the `diverging` offset in d3 is named `sign` in recharts)\n *//**\n * @deprecated use either `CartesianLayout` or `PolarLayout` instead.\n * Mixing both charts families leads to ambiguity in the type system.\n * These two layouts share very few properties, so it is best to keep them separate.\n *//**\n * @deprecated do not use: too many properties, mixing too many concepts, cartesian and polar together, everything optional.\n * Instead, use either `Coordinate` or `PolarCoordinate`.\n */export var isPolarCoordinate=c=>{return'radius'in c&&'startAngle'in c&&'endAngle'in c;};//\n// Event Handler Types -- Copied from @types/react/index.d.ts and adapted for Props.\n//\n/** The type of easing function to use for animations *//** Specifies the duration of animation, the unit of this option is ms. *//**\n * This object defines the offset of the chart area and width and height and brush and ... it's a bit too much information all in one.\n * We use it internally but let's not expose it to the outside world.\n * If you are looking for this information, instead import `ChartOffset` or `PlotArea` from `recharts`.\n *//**\n * The domain of axis.\n * This is the definition\n *\n * Numeric domain is always defined by an array of exactly two values, for the min and the max of the axis.\n * Categorical domain is defined as array of all possible values.\n *\n * Can be specified in many ways:\n * - array of numbers\n * - with special strings like 'dataMin' and 'dataMax'\n * - with special string math like 'dataMin - 100'\n * - with keyword 'auto'\n * - or a function\n * - array of functions\n * - or a combination of the above\n *//**\n * NumberDomain is an evaluated {@link AxisDomain}.\n * Unlike {@link AxisDomain}, it has no variety - it's a tuple of two number.\n * This is after all the keywords and functions were evaluated and what is left is [min, max].\n *\n * Know that the min, max values are not guaranteed to be nice numbers - values like -Infinity or NaN are possible.\n *\n * There are also `category` axes that have different things than numbers in their domain.\n *//** The props definition of base axis *//** Defines how ticks are placed and whether / how tick collisions are handled.\n * 'preserveStart' keeps the left tick on collision and ensures that the first tick is always shown.\n * 'preserveEnd' keeps the right tick on collision and ensures that the last tick is always shown.\n * 'preserveStartEnd' keeps the left tick on collision and ensures that the first and last ticks always show.\n * 'equidistantPreserveStart' selects a number N such that every nTh tick will be shown without collision.\n *//**\n * Ticks can be any type when the axis is the type of category.\n *\n * Ticks must be numbers when the axis is the type of number.\n */export var adaptEventHandlers=(props,newHandler)=>{if(!props||typeof props==='function'||typeof props==='boolean'){return null;}var inputProps=props;if(/*#__PURE__*/isValidElement(props)){inputProps=props.props;}if(typeof inputProps!=='object'&&typeof inputProps!=='function'){return null;}var out={};Object.keys(inputProps).forEach(key=>{if(isEventKey(key)){out[key]=newHandler||(e=>inputProps[key](inputProps,e));}});return out;};var getEventHandlerOfChild=(originalHandler,data,index)=>e=>{originalHandler(data,index,e);return null;};export var adaptEventsOfChild=(props,data,index)=>{if(props===null||typeof props!=='object'&&typeof props!=='function'){return null;}var out=null;Object.keys(props).forEach(key=>{var item=props[key];if(isEventKey(key)&&typeof item==='function'){if(!out)out={};out[key]=getEventHandlerOfChild(item,data,index);}});return out;};/**\n * 'axis' means that all graphical items belonging to this axis tick will be highlighted,\n * and all will be present in the tooltip.\n * Tooltip with 'axis' will display when hovering on the chart background.\n *\n * 'item' means only the one graphical item being hovered will show in the tooltip.\n * Tooltip with 'item' will display when hovering over individual graphical items.\n *\n * This is calculated internally;\n * charts have a `defaultTooltipEventType` and `validateTooltipEventTypes` options.\n *\n * Users then use <Tooltip shared={true} /> or <Tooltip shared={false} /> to control their preference,\n * and charts will then see what is allowed and what is not.\n *//**\n * These are the props we are going to pass to an `activeDot` or `dot` if it is a function or a custom Component\n *//**\n * This is the type of `activeDot` prop on:\n * - Area\n * - Line\n * - Radar\n *//**\n * Inside the dot event handlers we provide extra information about the dot point\n * that the Dot component itself does not need but users might find useful.\n *//**\n * This is the type of `dot` prop on:\n * - Area\n * - Line\n * - Radar\n *//**\n * Simplified version of the MouseEvent so that we don't have to mock the whole thing in tests.\n *\n * This is meant to represent the React.MouseEvent\n * which is a wrapper on top of https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n *//**\n * Coordinates relative to the top-left corner of the chart.\n * Also include scale which means that a chart that's scaled will return the same coordinates as a chart that's not scaled.\n */export var isNonEmptyArray=arr=>{return Array.isArray(arr)&&arr.length>0;};","map":{"version":3,"names":["isValidElement","isEventKey","isPolarCoordinate","c","adaptEventHandlers","props","newHandler","inputProps","out","Object","keys","forEach","key","e","getEventHandlerOfChild","originalHandler","data","index","adaptEventsOfChild","item","isNonEmptyArray","arr","Array","isArray","length"],"sources":["E:/program/ai交友网站demo/dating-app/frontend/src/node_modules/recharts/es6/util/types.js"],"sourcesContent":["import { isValidElement } from 'react';\nimport { isEventKey } from './excludeEventProps';\n\n/**\n * Determines how values are stacked:\n *\n * - `none` is the default, it adds values on top of each other. No smarts. Negative values will overlap.\n * - `expand` make it so that the values always add up to 1 - so the chart will look like a rectangle.\n * - `wiggle` and `silhouette` tries to keep the chart centered.\n * - `sign` stacks positive values above zero and negative values below zero. Similar to `none` but handles negatives.\n * - `positive` ignores all negative values, and then behaves like \\`none\\`.\n *\n * Also see https://d3js.org/d3-shape/stack#stack-offsets\n * (note that the `diverging` offset in d3 is named `sign` in recharts)\n */\n\n/**\n * @deprecated use either `CartesianLayout` or `PolarLayout` instead.\n * Mixing both charts families leads to ambiguity in the type system.\n * These two layouts share very few properties, so it is best to keep them separate.\n */\n\n/**\n * @deprecated do not use: too many properties, mixing too many concepts, cartesian and polar together, everything optional.\n * Instead, use either `Coordinate` or `PolarCoordinate`.\n */\n\nexport var isPolarCoordinate = c => {\n  return 'radius' in c && 'startAngle' in c && 'endAngle' in c;\n};\n\n//\n// Event Handler Types -- Copied from @types/react/index.d.ts and adapted for Props.\n//\n\n/** The type of easing function to use for animations */\n\n/** Specifies the duration of animation, the unit of this option is ms. */\n\n/**\n * This object defines the offset of the chart area and width and height and brush and ... it's a bit too much information all in one.\n * We use it internally but let's not expose it to the outside world.\n * If you are looking for this information, instead import `ChartOffset` or `PlotArea` from `recharts`.\n */\n\n/**\n * The domain of axis.\n * This is the definition\n *\n * Numeric domain is always defined by an array of exactly two values, for the min and the max of the axis.\n * Categorical domain is defined as array of all possible values.\n *\n * Can be specified in many ways:\n * - array of numbers\n * - with special strings like 'dataMin' and 'dataMax'\n * - with special string math like 'dataMin - 100'\n * - with keyword 'auto'\n * - or a function\n * - array of functions\n * - or a combination of the above\n */\n\n/**\n * NumberDomain is an evaluated {@link AxisDomain}.\n * Unlike {@link AxisDomain}, it has no variety - it's a tuple of two number.\n * This is after all the keywords and functions were evaluated and what is left is [min, max].\n *\n * Know that the min, max values are not guaranteed to be nice numbers - values like -Infinity or NaN are possible.\n *\n * There are also `category` axes that have different things than numbers in their domain.\n */\n\n/** The props definition of base axis */\n\n/** Defines how ticks are placed and whether / how tick collisions are handled.\n * 'preserveStart' keeps the left tick on collision and ensures that the first tick is always shown.\n * 'preserveEnd' keeps the right tick on collision and ensures that the last tick is always shown.\n * 'preserveStartEnd' keeps the left tick on collision and ensures that the first and last ticks always show.\n * 'equidistantPreserveStart' selects a number N such that every nTh tick will be shown without collision.\n */\n\n/**\n * Ticks can be any type when the axis is the type of category.\n *\n * Ticks must be numbers when the axis is the type of number.\n */\n\nexport var adaptEventHandlers = (props, newHandler) => {\n  if (!props || typeof props === 'function' || typeof props === 'boolean') {\n    return null;\n  }\n  var inputProps = props;\n  if (/*#__PURE__*/isValidElement(props)) {\n    inputProps = props.props;\n  }\n  if (typeof inputProps !== 'object' && typeof inputProps !== 'function') {\n    return null;\n  }\n  var out = {};\n  Object.keys(inputProps).forEach(key => {\n    if (isEventKey(key)) {\n      out[key] = newHandler || (e => inputProps[key](inputProps, e));\n    }\n  });\n  return out;\n};\nvar getEventHandlerOfChild = (originalHandler, data, index) => e => {\n  originalHandler(data, index, e);\n  return null;\n};\nexport var adaptEventsOfChild = (props, data, index) => {\n  if (props === null || typeof props !== 'object' && typeof props !== 'function') {\n    return null;\n  }\n  var out = null;\n  Object.keys(props).forEach(key => {\n    var item = props[key];\n    if (isEventKey(key) && typeof item === 'function') {\n      if (!out) out = {};\n      out[key] = getEventHandlerOfChild(item, data, index);\n    }\n  });\n  return out;\n};\n\n/**\n * 'axis' means that all graphical items belonging to this axis tick will be highlighted,\n * and all will be present in the tooltip.\n * Tooltip with 'axis' will display when hovering on the chart background.\n *\n * 'item' means only the one graphical item being hovered will show in the tooltip.\n * Tooltip with 'item' will display when hovering over individual graphical items.\n *\n * This is calculated internally;\n * charts have a `defaultTooltipEventType` and `validateTooltipEventTypes` options.\n *\n * Users then use <Tooltip shared={true} /> or <Tooltip shared={false} /> to control their preference,\n * and charts will then see what is allowed and what is not.\n */\n\n/**\n * These are the props we are going to pass to an `activeDot` or `dot` if it is a function or a custom Component\n */\n\n/**\n * This is the type of `activeDot` prop on:\n * - Area\n * - Line\n * - Radar\n */\n\n/**\n * Inside the dot event handlers we provide extra information about the dot point\n * that the Dot component itself does not need but users might find useful.\n */\n\n/**\n * This is the type of `dot` prop on:\n * - Area\n * - Line\n * - Radar\n */\n\n/**\n * Simplified version of the MouseEvent so that we don't have to mock the whole thing in tests.\n *\n * This is meant to represent the React.MouseEvent\n * which is a wrapper on top of https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n */\n\n/**\n * Coordinates relative to the top-left corner of the chart.\n * Also include scale which means that a chart that's scaled will return the same coordinates as a chart that's not scaled.\n */\n\nexport var isNonEmptyArray = arr => {\n  return Array.isArray(arr) && arr.length > 0;\n};"],"mappings":"AAAA,OAASA,cAAc,KAAQ,OAAO,CACtC,OAASC,UAAU,KAAQ,qBAAqB,CAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAEA;AACA;AACA;AACA;AACA,GAEA;AACA;AACA;AACA,GAEA,MAAO,IAAI,CAAAC,iBAAiB,CAAGC,CAAC,EAAI,CAClC,MAAO,QAAQ,EAAI,CAAAA,CAAC,EAAI,YAAY,EAAI,CAAAA,CAAC,EAAI,UAAU,EAAI,CAAAA,CAAC,CAC9D,CAAC,CAED;AACA;AACA;AAEA,wDAEA,0EAEA;AACA;AACA;AACA;AACA,GAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAEA,wCAEA;AACA;AACA;AACA;AACA;AACA,GAEA;AACA;AACA;AACA;AACA,GAEA,MAAO,IAAI,CAAAC,kBAAkB,CAAGA,CAACC,KAAK,CAAEC,UAAU,GAAK,CACrD,GAAI,CAACD,KAAK,EAAI,MAAO,CAAAA,KAAK,GAAK,UAAU,EAAI,MAAO,CAAAA,KAAK,GAAK,SAAS,CAAE,CACvE,MAAO,KAAI,CACb,CACA,GAAI,CAAAE,UAAU,CAAGF,KAAK,CACtB,GAAI,aAAaL,cAAc,CAACK,KAAK,CAAC,CAAE,CACtCE,UAAU,CAAGF,KAAK,CAACA,KAAK,CAC1B,CACA,GAAI,MAAO,CAAAE,UAAU,GAAK,QAAQ,EAAI,MAAO,CAAAA,UAAU,GAAK,UAAU,CAAE,CACtE,MAAO,KAAI,CACb,CACA,GAAI,CAAAC,GAAG,CAAG,CAAC,CAAC,CACZC,MAAM,CAACC,IAAI,CAACH,UAAU,CAAC,CAACI,OAAO,CAACC,GAAG,EAAI,CACrC,GAAIX,UAAU,CAACW,GAAG,CAAC,CAAE,CACnBJ,GAAG,CAACI,GAAG,CAAC,CAAGN,UAAU,GAAKO,CAAC,EAAIN,UAAU,CAACK,GAAG,CAAC,CAACL,UAAU,CAAEM,CAAC,CAAC,CAAC,CAChE,CACF,CAAC,CAAC,CACF,MAAO,CAAAL,GAAG,CACZ,CAAC,CACD,GAAI,CAAAM,sBAAsB,CAAGA,CAACC,eAAe,CAAEC,IAAI,CAAEC,KAAK,GAAKJ,CAAC,EAAI,CAClEE,eAAe,CAACC,IAAI,CAAEC,KAAK,CAAEJ,CAAC,CAAC,CAC/B,MAAO,KAAI,CACb,CAAC,CACD,MAAO,IAAI,CAAAK,kBAAkB,CAAGA,CAACb,KAAK,CAAEW,IAAI,CAAEC,KAAK,GAAK,CACtD,GAAIZ,KAAK,GAAK,IAAI,EAAI,MAAO,CAAAA,KAAK,GAAK,QAAQ,EAAI,MAAO,CAAAA,KAAK,GAAK,UAAU,CAAE,CAC9E,MAAO,KAAI,CACb,CACA,GAAI,CAAAG,GAAG,CAAG,IAAI,CACdC,MAAM,CAACC,IAAI,CAACL,KAAK,CAAC,CAACM,OAAO,CAACC,GAAG,EAAI,CAChC,GAAI,CAAAO,IAAI,CAAGd,KAAK,CAACO,GAAG,CAAC,CACrB,GAAIX,UAAU,CAACW,GAAG,CAAC,EAAI,MAAO,CAAAO,IAAI,GAAK,UAAU,CAAE,CACjD,GAAI,CAACX,GAAG,CAAEA,GAAG,CAAG,CAAC,CAAC,CAClBA,GAAG,CAACI,GAAG,CAAC,CAAGE,sBAAsB,CAACK,IAAI,CAAEH,IAAI,CAAEC,KAAK,CAAC,CACtD,CACF,CAAC,CAAC,CACF,MAAO,CAAAT,GAAG,CACZ,CAAC,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAEA;AACA;AACA,GAEA;AACA;AACA;AACA;AACA;AACA,GAEA;AACA;AACA;AACA,GAEA;AACA;AACA;AACA;AACA;AACA,GAEA;AACA;AACA;AACA;AACA;AACA,GAEA;AACA;AACA;AACA,GAEA,MAAO,IAAI,CAAAY,eAAe,CAAGC,GAAG,EAAI,CAClC,MAAO,CAAAC,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC,EAAIA,GAAG,CAACG,MAAM,CAAG,CAAC,CAC7C,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}