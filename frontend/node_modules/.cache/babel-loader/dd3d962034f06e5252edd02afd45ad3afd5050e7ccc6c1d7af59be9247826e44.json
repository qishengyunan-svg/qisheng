{"ast":null,"code":"import{isVisible}from'../util/TickUtils';import{getEveryNthWithCondition}from'../util/getEveryNthWithCondition';export function getEquidistantTicks(sign,boundaries,getTickSize,ticks,minTickGap){// If the ticks are readonly, then the slice might not be necessary\nvar result=(ticks||[]).slice();var{start:initialStart,end}=boundaries;var index=0;// Premature optimisation idea 1: Estimate a lower bound, and start from there.\n// For now, start from every tick\nvar stepsize=1;var start=initialStart;var _loop=function _loop(){// Given stepsize, evaluate whether every stepsize-th tick can be shown.\n// If it can not, then increase the stepsize by 1, and try again.\nvar entry=ticks===null||ticks===void 0?void 0:ticks[index];// Break condition - If we have evaluated all the ticks, then we are done.\nif(entry===undefined){return{v:getEveryNthWithCondition(ticks,stepsize)};}// Check if the element collides with the next element\nvar i=index;var size;var getSize=()=>{if(size===undefined){size=getTickSize(entry,i);}return size;};var tickCoord=entry.coordinate;// We will always show the first tick.\nvar isShow=index===0||isVisible(sign,tickCoord,getSize,start,end);if(!isShow){// Start all over with a larger stepsize\nindex=0;start=initialStart;stepsize+=1;}if(isShow){// If it can be shown, update the start\nstart=tickCoord+sign*(getSize()/2+minTickGap);index+=stepsize;}},_ret;while(stepsize<=result.length){_ret=_loop();if(_ret)return _ret.v;}return[];}","map":{"version":3,"names":["isVisible","getEveryNthWithCondition","getEquidistantTicks","sign","boundaries","getTickSize","ticks","minTickGap","result","slice","start","initialStart","end","index","stepsize","_loop","entry","undefined","v","i","size","getSize","tickCoord","coordinate","isShow","_ret","length"],"sources":["E:/program/ai交友网站demo/dating-app/frontend/src/node_modules/recharts/es6/cartesian/getEquidistantTicks.js"],"sourcesContent":["import { isVisible } from '../util/TickUtils';\nimport { getEveryNthWithCondition } from '../util/getEveryNthWithCondition';\nexport function getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n  // If the ticks are readonly, then the slice might not be necessary\n  var result = (ticks || []).slice();\n  var {\n    start: initialStart,\n    end\n  } = boundaries;\n  var index = 0;\n  // Premature optimisation idea 1: Estimate a lower bound, and start from there.\n  // For now, start from every tick\n  var stepsize = 1;\n  var start = initialStart;\n  var _loop = function _loop() {\n      // Given stepsize, evaluate whether every stepsize-th tick can be shown.\n      // If it can not, then increase the stepsize by 1, and try again.\n\n      var entry = ticks === null || ticks === void 0 ? void 0 : ticks[index];\n\n      // Break condition - If we have evaluated all the ticks, then we are done.\n      if (entry === undefined) {\n        return {\n          v: getEveryNthWithCondition(ticks, stepsize)\n        };\n      }\n\n      // Check if the element collides with the next element\n      var i = index;\n      var size;\n      var getSize = () => {\n        if (size === undefined) {\n          size = getTickSize(entry, i);\n        }\n        return size;\n      };\n      var tickCoord = entry.coordinate;\n      // We will always show the first tick.\n      var isShow = index === 0 || isVisible(sign, tickCoord, getSize, start, end);\n      if (!isShow) {\n        // Start all over with a larger stepsize\n        index = 0;\n        start = initialStart;\n        stepsize += 1;\n      }\n      if (isShow) {\n        // If it can be shown, update the start\n        start = tickCoord + sign * (getSize() / 2 + minTickGap);\n        index += stepsize;\n      }\n    },\n    _ret;\n  while (stepsize <= result.length) {\n    _ret = _loop();\n    if (_ret) return _ret.v;\n  }\n  return [];\n}"],"mappings":"AAAA,OAASA,SAAS,KAAQ,mBAAmB,CAC7C,OAASC,wBAAwB,KAAQ,kCAAkC,CAC3E,MAAO,SAAS,CAAAC,mBAAmBA,CAACC,IAAI,CAAEC,UAAU,CAAEC,WAAW,CAAEC,KAAK,CAAEC,UAAU,CAAE,CACpF;AACA,GAAI,CAAAC,MAAM,CAAG,CAACF,KAAK,EAAI,EAAE,EAAEG,KAAK,CAAC,CAAC,CAClC,GAAI,CACFC,KAAK,CAAEC,YAAY,CACnBC,GACF,CAAC,CAAGR,UAAU,CACd,GAAI,CAAAS,KAAK,CAAG,CAAC,CACb;AACA;AACA,GAAI,CAAAC,QAAQ,CAAG,CAAC,CAChB,GAAI,CAAAJ,KAAK,CAAGC,YAAY,CACxB,GAAI,CAAAI,KAAK,CAAG,QAAS,CAAAA,KAAKA,CAAA,CAAG,CACzB;AACA;AAEA,GAAI,CAAAC,KAAK,CAAGV,KAAK,GAAK,IAAI,EAAIA,KAAK,GAAK,IAAK,EAAC,CAAG,IAAK,EAAC,CAAGA,KAAK,CAACO,KAAK,CAAC,CAEtE;AACA,GAAIG,KAAK,GAAKC,SAAS,CAAE,CACvB,MAAO,CACLC,CAAC,CAAEjB,wBAAwB,CAACK,KAAK,CAAEQ,QAAQ,CAC7C,CAAC,CACH,CAEA;AACA,GAAI,CAAAK,CAAC,CAAGN,KAAK,CACb,GAAI,CAAAO,IAAI,CACR,GAAI,CAAAC,OAAO,CAAGA,CAAA,GAAM,CAClB,GAAID,IAAI,GAAKH,SAAS,CAAE,CACtBG,IAAI,CAAGf,WAAW,CAACW,KAAK,CAAEG,CAAC,CAAC,CAC9B,CACA,MAAO,CAAAC,IAAI,CACb,CAAC,CACD,GAAI,CAAAE,SAAS,CAAGN,KAAK,CAACO,UAAU,CAChC;AACA,GAAI,CAAAC,MAAM,CAAGX,KAAK,GAAK,CAAC,EAAIb,SAAS,CAACG,IAAI,CAAEmB,SAAS,CAAED,OAAO,CAAEX,KAAK,CAAEE,GAAG,CAAC,CAC3E,GAAI,CAACY,MAAM,CAAE,CACX;AACAX,KAAK,CAAG,CAAC,CACTH,KAAK,CAAGC,YAAY,CACpBG,QAAQ,EAAI,CAAC,CACf,CACA,GAAIU,MAAM,CAAE,CACV;AACAd,KAAK,CAAGY,SAAS,CAAGnB,IAAI,EAAIkB,OAAO,CAAC,CAAC,CAAG,CAAC,CAAGd,UAAU,CAAC,CACvDM,KAAK,EAAIC,QAAQ,CACnB,CACF,CAAC,CACDW,IAAI,CACN,MAAOX,QAAQ,EAAIN,MAAM,CAACkB,MAAM,CAAE,CAChCD,IAAI,CAAGV,KAAK,CAAC,CAAC,CACd,GAAIU,IAAI,CAAE,MAAO,CAAAA,IAAI,CAACP,CAAC,CACzB,CACA,MAAO,EAAE,CACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}