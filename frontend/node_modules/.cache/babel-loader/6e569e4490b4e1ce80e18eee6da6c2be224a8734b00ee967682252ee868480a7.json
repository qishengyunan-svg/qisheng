{"ast":null,"code":"import{createAction,createListenerMiddleware}from'@reduxjs/toolkit';import{selectActiveLabel,selectActiveTooltipCoordinate,selectActiveTooltipDataKey,selectActiveTooltipIndex,selectIsTooltipActive}from'./selectors/tooltipSelectors';export var externalEventAction=createAction('externalEvent');export var externalEventsMiddleware=createListenerMiddleware();/*\n * We need a Map keyed by event type because this middleware handles MULTIPLE different event types\n * (click, mouseenter, mouseleave, mousedown, mouseup, contextmenu, dblclick, touchstart, touchmove, touchend)\n * from the same DOM element. Different event types should NOT cancel each other's animation frames.\n * For example, a click event and a mousemove event can happen in quick succession and both should be processed.\n * This is different from mouseMoveMiddleware which only handles one event type and uses a single rafId.\n */var rafIdMap=new Map();externalEventsMiddleware.startListening({actionCreator:externalEventAction,effect:(action,listenerApi)=>{var{handler,reactEvent}=action.payload;if(handler==null){return;}reactEvent.persist();var eventType=reactEvent.type;// Cancel any pending animation frame for this event type\nvar existingRafId=rafIdMap.get(eventType);if(existingRafId!==undefined){cancelAnimationFrame(existingRafId);}var rafId=requestAnimationFrame(()=>{try{/*\n         * Here it is important that we get the latest state inside the animation frame callback,\n         * not from the outer scope, because there may have been other actions dispatched\n         * between the time the event was fired and the animation frame callback is executed.\n         * One of those actions is the one that actually sets the active tooltip state!\n         */var state=listenerApi.getState();var nextState={activeCoordinate:selectActiveTooltipCoordinate(state),activeDataKey:selectActiveTooltipDataKey(state),activeIndex:selectActiveTooltipIndex(state),activeLabel:selectActiveLabel(state),activeTooltipIndex:selectActiveTooltipIndex(state),isTooltipActive:selectIsTooltipActive(state)};handler(nextState,reactEvent);}finally{rafIdMap.delete(eventType);}});rafIdMap.set(eventType,rafId);}});","map":{"version":3,"names":["createAction","createListenerMiddleware","selectActiveLabel","selectActiveTooltipCoordinate","selectActiveTooltipDataKey","selectActiveTooltipIndex","selectIsTooltipActive","externalEventAction","externalEventsMiddleware","rafIdMap","Map","startListening","actionCreator","effect","action","listenerApi","handler","reactEvent","payload","persist","eventType","type","existingRafId","get","undefined","cancelAnimationFrame","rafId","requestAnimationFrame","state","getState","nextState","activeCoordinate","activeDataKey","activeIndex","activeLabel","activeTooltipIndex","isTooltipActive","delete","set"],"sources":["E:/program/ai交友网站demo/dating-app/frontend/src/node_modules/recharts/es6/state/externalEventsMiddleware.js"],"sourcesContent":["import { createAction, createListenerMiddleware } from '@reduxjs/toolkit';\nimport { selectActiveLabel, selectActiveTooltipCoordinate, selectActiveTooltipDataKey, selectActiveTooltipIndex, selectIsTooltipActive } from './selectors/tooltipSelectors';\nexport var externalEventAction = createAction('externalEvent');\nexport var externalEventsMiddleware = createListenerMiddleware();\n\n/*\n * We need a Map keyed by event type because this middleware handles MULTIPLE different event types\n * (click, mouseenter, mouseleave, mousedown, mouseup, contextmenu, dblclick, touchstart, touchmove, touchend)\n * from the same DOM element. Different event types should NOT cancel each other's animation frames.\n * For example, a click event and a mousemove event can happen in quick succession and both should be processed.\n * This is different from mouseMoveMiddleware which only handles one event type and uses a single rafId.\n */\nvar rafIdMap = new Map();\nexternalEventsMiddleware.startListening({\n  actionCreator: externalEventAction,\n  effect: (action, listenerApi) => {\n    var {\n      handler,\n      reactEvent\n    } = action.payload;\n    if (handler == null) {\n      return;\n    }\n    reactEvent.persist();\n    var eventType = reactEvent.type;\n\n    // Cancel any pending animation frame for this event type\n    var existingRafId = rafIdMap.get(eventType);\n    if (existingRafId !== undefined) {\n      cancelAnimationFrame(existingRafId);\n    }\n    var rafId = requestAnimationFrame(() => {\n      try {\n        /*\n         * Here it is important that we get the latest state inside the animation frame callback,\n         * not from the outer scope, because there may have been other actions dispatched\n         * between the time the event was fired and the animation frame callback is executed.\n         * One of those actions is the one that actually sets the active tooltip state!\n         */\n        var state = listenerApi.getState();\n        var nextState = {\n          activeCoordinate: selectActiveTooltipCoordinate(state),\n          activeDataKey: selectActiveTooltipDataKey(state),\n          activeIndex: selectActiveTooltipIndex(state),\n          activeLabel: selectActiveLabel(state),\n          activeTooltipIndex: selectActiveTooltipIndex(state),\n          isTooltipActive: selectIsTooltipActive(state)\n        };\n        handler(nextState, reactEvent);\n      } finally {\n        rafIdMap.delete(eventType);\n      }\n    });\n    rafIdMap.set(eventType, rafId);\n  }\n});"],"mappings":"AAAA,OAASA,YAAY,CAAEC,wBAAwB,KAAQ,kBAAkB,CACzE,OAASC,iBAAiB,CAAEC,6BAA6B,CAAEC,0BAA0B,CAAEC,wBAAwB,CAAEC,qBAAqB,KAAQ,8BAA8B,CAC5K,MAAO,IAAI,CAAAC,mBAAmB,CAAGP,YAAY,CAAC,eAAe,CAAC,CAC9D,MAAO,IAAI,CAAAQ,wBAAwB,CAAGP,wBAAwB,CAAC,CAAC,CAEhE;AACA;AACA;AACA;AACA;AACA;AACA,GACA,GAAI,CAAAQ,QAAQ,CAAG,GAAI,CAAAC,GAAG,CAAC,CAAC,CACxBF,wBAAwB,CAACG,cAAc,CAAC,CACtCC,aAAa,CAAEL,mBAAmB,CAClCM,MAAM,CAAEA,CAACC,MAAM,CAAEC,WAAW,GAAK,CAC/B,GAAI,CACFC,OAAO,CACPC,UACF,CAAC,CAAGH,MAAM,CAACI,OAAO,CAClB,GAAIF,OAAO,EAAI,IAAI,CAAE,CACnB,OACF,CACAC,UAAU,CAACE,OAAO,CAAC,CAAC,CACpB,GAAI,CAAAC,SAAS,CAAGH,UAAU,CAACI,IAAI,CAE/B;AACA,GAAI,CAAAC,aAAa,CAAGb,QAAQ,CAACc,GAAG,CAACH,SAAS,CAAC,CAC3C,GAAIE,aAAa,GAAKE,SAAS,CAAE,CAC/BC,oBAAoB,CAACH,aAAa,CAAC,CACrC,CACA,GAAI,CAAAI,KAAK,CAAGC,qBAAqB,CAAC,IAAM,CACtC,GAAI,CACF;AACR;AACA;AACA;AACA;AACA,WACQ,GAAI,CAAAC,KAAK,CAAGb,WAAW,CAACc,QAAQ,CAAC,CAAC,CAClC,GAAI,CAAAC,SAAS,CAAG,CACdC,gBAAgB,CAAE5B,6BAA6B,CAACyB,KAAK,CAAC,CACtDI,aAAa,CAAE5B,0BAA0B,CAACwB,KAAK,CAAC,CAChDK,WAAW,CAAE5B,wBAAwB,CAACuB,KAAK,CAAC,CAC5CM,WAAW,CAAEhC,iBAAiB,CAAC0B,KAAK,CAAC,CACrCO,kBAAkB,CAAE9B,wBAAwB,CAACuB,KAAK,CAAC,CACnDQ,eAAe,CAAE9B,qBAAqB,CAACsB,KAAK,CAC9C,CAAC,CACDZ,OAAO,CAACc,SAAS,CAAEb,UAAU,CAAC,CAChC,CAAC,OAAS,CACRR,QAAQ,CAAC4B,MAAM,CAACjB,SAAS,CAAC,CAC5B,CACF,CAAC,CAAC,CACFX,QAAQ,CAAC6B,GAAG,CAAClB,SAAS,CAAEM,KAAK,CAAC,CAChC,CACF,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}